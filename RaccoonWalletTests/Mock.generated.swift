// Generated using Sourcery 0.15.0 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT


//swiftlint:disable force_cast
//swiftlint:disable function_body_length
//swiftlint:disable line_length
//swiftlint:disable vertical_whitespace

#if MockyCustom
import SwiftyMocky
import NemSwift
import RxSwift
import RxBlocking
@testable import RaccoonWallet

    public final class MockyAssertion {
        public static var handler: ((Bool, String, StaticString, UInt) -> Void)?
    }

    func MockyAssert(_ expression: @autoclosure () -> Bool, _ message: @autoclosure () -> String = "Verification failed", file: StaticString = #file, line: UInt = #line) {
        guard let handler = MockyAssertion.handler else {
            assert(expression, message, file: file, line: line)
            return
        }

        handler(expression(), message(), file, line)
    }
#elseif Mocky
import SwiftyMocky
import XCTest
import NemSwift
import RxSwift
import RxBlocking
@testable import RaccoonWallet

    func MockyAssert(_ expression: @autoclosure () -> Bool, _ message: @autoclosure () -> String = "Verification failed", file: StaticString = #file, line: UInt = #line) {
        XCTAssert(expression(), message(), file: file, line: line)
    }
#else
import Sourcery
import SourceryRuntime
#endif


// MARK: - AboutInteractorOutput
class AboutInteractorOutputMock: AboutInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AboutPresentation
class AboutPresentationMock: AboutPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: AboutView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "AboutPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (AboutView)?

    var interactor: AboutUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "AboutPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (AboutUseCase)?

    var router: AboutWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "AboutPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (AboutWireframe)?





    func didClickOfficialSite() {
        addInvocation(.m_didClickOfficialSite)
		let perform = methodPerformValue(.m_didClickOfficialSite) as? () -> Void
		perform?()
    }

    func didClickDiscord() {
        addInvocation(.m_didClickDiscord)
		let perform = methodPerformValue(.m_didClickDiscord) as? () -> Void
		perform?()
    }

    func didClickOpenSource() {
        addInvocation(.m_didClickOpenSource)
		let perform = methodPerformValue(.m_didClickOpenSource) as? () -> Void
		perform?()
    }

    func didClickReview() {
        addInvocation(.m_didClickReview)
		let perform = methodPerformValue(.m_didClickReview) as? () -> Void
		perform?()
    }

    func didClickPrivacyPolicy() {
        addInvocation(.m_didClickPrivacyPolicy)
		let perform = methodPerformValue(.m_didClickPrivacyPolicy) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickOfficialSite
        case m_didClickDiscord
        case m_didClickOpenSource
        case m_didClickReview
        case m_didClickPrivacyPolicy
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<AboutView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<AboutUseCase?>)
        case p_router_get
		case p_router_set(Parameter<AboutWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickOfficialSite, .m_didClickOfficialSite):
                return true 
            case (.m_didClickDiscord, .m_didClickDiscord):
                return true 
            case (.m_didClickOpenSource, .m_didClickOpenSource):
                return true 
            case (.m_didClickReview, .m_didClickReview):
                return true 
            case (.m_didClickPrivacyPolicy, .m_didClickPrivacyPolicy):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<AboutView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<AboutUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<AboutWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickOfficialSite: return 0
            case .m_didClickDiscord: return 0
            case .m_didClickOpenSource: return 0
            case .m_didClickReview: return 0
            case .m_didClickPrivacyPolicy: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: AboutView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: AboutUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: AboutWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickOfficialSite() -> Verify { return Verify(method: .m_didClickOfficialSite)}
        static func didClickDiscord() -> Verify { return Verify(method: .m_didClickDiscord)}
        static func didClickOpenSource() -> Verify { return Verify(method: .m_didClickOpenSource)}
        static func didClickReview() -> Verify { return Verify(method: .m_didClickReview)}
        static func didClickPrivacyPolicy() -> Verify { return Verify(method: .m_didClickPrivacyPolicy)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<AboutView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<AboutUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<AboutWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickOfficialSite(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOfficialSite, performs: perform)
        }
        static func didClickDiscord(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickDiscord, performs: perform)
        }
        static func didClickOpenSource(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOpenSource, performs: perform)
        }
        static func didClickReview(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickReview, performs: perform)
        }
        static func didClickPrivacyPolicy(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickPrivacyPolicy, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AboutUseCase
class AboutUseCaseMock: AboutUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: AboutInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "AboutUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (AboutInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<AboutInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<AboutInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: AboutInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<AboutInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AboutView
class AboutViewMock: AboutView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: AboutPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "AboutViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (AboutPresentation)?





    func showReviewInApp() {
        addInvocation(.m_showReviewInApp)
		let perform = methodPerformValue(.m_showReviewInApp) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showReviewInApp
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<AboutPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showReviewInApp, .m_showReviewInApp):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<AboutPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showReviewInApp: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: AboutPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showReviewInApp() -> Verify { return Verify(method: .m_showReviewInApp)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<AboutPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showReviewInApp(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showReviewInApp, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - AboutWireframe
class AboutWireframeMock: AboutWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "AboutWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentOfficialSite() {
        addInvocation(.m_presentOfficialSite)
		let perform = methodPerformValue(.m_presentOfficialSite) as? () -> Void
		perform?()
    }

    func presentDiscord() {
        addInvocation(.m_presentDiscord)
		let perform = methodPerformValue(.m_presentDiscord) as? () -> Void
		perform?()
    }

    func presentOpenSource() {
        addInvocation(.m_presentOpenSource)
		let perform = methodPerformValue(.m_presentOpenSource) as? () -> Void
		perform?()
    }

    func presentReview() {
        addInvocation(.m_presentReview)
		let perform = methodPerformValue(.m_presentReview) as? () -> Void
		perform?()
    }

    func presentPrivacyPolicy() {
        addInvocation(.m_presentPrivacyPolicy)
		let perform = methodPerformValue(.m_presentPrivacyPolicy) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentOfficialSite
        case m_presentDiscord
        case m_presentOpenSource
        case m_presentReview
        case m_presentPrivacyPolicy
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentOfficialSite, .m_presentOfficialSite):
                return true 
            case (.m_presentDiscord, .m_presentDiscord):
                return true 
            case (.m_presentOpenSource, .m_presentOpenSource):
                return true 
            case (.m_presentReview, .m_presentReview):
                return true 
            case (.m_presentPrivacyPolicy, .m_presentPrivacyPolicy):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentOfficialSite: return 0
            case .m_presentDiscord: return 0
            case .m_presentOpenSource: return 0
            case .m_presentReview: return 0
            case .m_presentPrivacyPolicy: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentOfficialSite() -> Verify { return Verify(method: .m_presentOfficialSite)}
        static func presentDiscord() -> Verify { return Verify(method: .m_presentDiscord)}
        static func presentOpenSource() -> Verify { return Verify(method: .m_presentOpenSource)}
        static func presentReview() -> Verify { return Verify(method: .m_presentReview)}
        static func presentPrivacyPolicy() -> Verify { return Verify(method: .m_presentPrivacyPolicy)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentOfficialSite(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentOfficialSite, performs: perform)
        }
        static func presentDiscord(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentDiscord, performs: perform)
        }
        static func presentOpenSource(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentOpenSource, performs: perform)
        }
        static func presentReview(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentReview, performs: perform)
        }
        static func presentPrivacyPolicy(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentPrivacyPolicy, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - BalanceDetailInteractorOutput
class BalanceDetailInteractorOutputMock: BalanceDetailInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func mosaicOwnedFetched(_ mosaics: [MosaicDetail]) {
        addInvocation(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`))) as? ([MosaicDetail]) -> Void
		perform?(`mosaics`)
    }

    func mosaicOwnedFetchFailed(_ error: Error) {
        addInvocation(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    func rateFetched(_ rate: Decimal) {
        addInvocation(.m_rateFetched__rate(Parameter<Decimal>.value(`rate`)))
		let perform = methodPerformValue(.m_rateFetched__rate(Parameter<Decimal>.value(`rate`))) as? (Decimal) -> Void
		perform?(`rate`)
    }

    func rateFetchFailed(_ error: Error) {
        addInvocation(.m_rateFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_rateFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>)
        case m_mosaicOwnedFetchFailed__error(Parameter<Error>)
        case m_rateFetched__rate(Parameter<Decimal>)
        case m_rateFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_mosaicOwnedFetched__mosaics(let lhsMosaics), .m_mosaicOwnedFetched__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_mosaicOwnedFetchFailed__error(let lhsError), .m_mosaicOwnedFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_rateFetched__rate(let lhsRate), .m_rateFetched__rate(let rhsRate)):
                guard Parameter.compare(lhs: lhsRate, rhs: rhsRate, with: matcher) else { return false } 
                return true 
            case (.m_rateFetchFailed__error(let lhsError), .m_rateFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_mosaicOwnedFetched__mosaics(p0): return p0.intValue
            case let .m_mosaicOwnedFetchFailed__error(p0): return p0.intValue
            case let .m_rateFetched__rate(p0): return p0.intValue
            case let .m_rateFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
        static func rateFetched(_ rate: Parameter<Decimal>) -> Verify { return Verify(method: .m_rateFetched__rate(`rate`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `rate` label")
		static func rateFetched(rate: Parameter<Decimal>) -> Verify { return Verify(method: .m_rateFetched__rate(`rate`))}
        static func rateFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_rateFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func rateFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_rateFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
        static func rateFetched(_ rate: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_rateFetched__rate(`rate`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `rate` label")
		static func rateFetched(rate: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_rateFetched__rate(`rate`), performs: perform)
        }
        static func rateFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_rateFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func rateFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_rateFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BalanceDetailPresentation
class BalanceDetailPresentationMock: BalanceDetailPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: BalanceDetailView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "BalanceDetailPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (BalanceDetailView)?

    var interactor: BalanceDetailUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "BalanceDetailPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (BalanceDetailUseCase)?

    var router: BalanceDetailWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "BalanceDetailPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (BalanceDetailWireframe)?





    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<BalanceDetailView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<BalanceDetailUseCase?>)
        case p_router_get
		case p_router_set(Parameter<BalanceDetailWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<BalanceDetailView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<BalanceDetailUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<BalanceDetailWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: BalanceDetailView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: BalanceDetailUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: BalanceDetailWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<BalanceDetailView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<BalanceDetailUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<BalanceDetailWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BalanceDetailUseCase
class BalanceDetailUseCaseMock: BalanceDetailUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: BalanceDetailInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "BalanceDetailUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (BalanceDetailInteractorOutput)?





    func fetchMosaicOwned(_ address: String) {
        addInvocation(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }

    func fetchRate(_ currency: Currency) {
        addInvocation(.m_fetchRate__currency(Parameter<Currency>.value(`currency`)))
		let perform = methodPerformValue(.m_fetchRate__currency(Parameter<Currency>.value(`currency`))) as? (Currency) -> Void
		perform?(`currency`)
    }


    fileprivate enum MethodType {
        case m_fetchMosaicOwned__address(Parameter<String>)
        case m_fetchRate__currency(Parameter<Currency>)
        case p_output_get
		case p_output_set(Parameter<BalanceDetailInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchMosaicOwned__address(let lhsAddress), .m_fetchMosaicOwned__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.m_fetchRate__currency(let lhsCurrency), .m_fetchRate__currency(let rhsCurrency)):
                guard Parameter.compare(lhs: lhsCurrency, rhs: rhsCurrency, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<BalanceDetailInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchMosaicOwned__address(p0): return p0.intValue
            case let .m_fetchRate__currency(p0): return p0.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: BalanceDetailInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchMosaicOwned(_ address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        static func fetchRate(_ currency: Parameter<Currency>) -> Verify { return Verify(method: .m_fetchRate__currency(`currency`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `currency` label")
		static func fetchRate(currency: Parameter<Currency>) -> Verify { return Verify(method: .m_fetchRate__currency(`currency`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<BalanceDetailInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchMosaicOwned(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        static func fetchRate(_ currency: Parameter<Currency>, perform: @escaping (Currency) -> Void) -> Perform {
            return Perform(method: .m_fetchRate__currency(`currency`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `currency` label")
		static func fetchRate(currency: Parameter<Currency>, perform: @escaping (Currency) -> Void) -> Perform {
            return Perform(method: .m_fetchRate__currency(`currency`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BalanceDetailView
class BalanceDetailViewMock: BalanceDetailView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: BalanceDetailPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "BalanceDetailViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (BalanceDetailPresentation)?





    func showBalanceLoading() {
        addInvocation(.m_showBalanceLoading)
		let perform = methodPerformValue(.m_showBalanceLoading) as? () -> Void
		perform?()
    }

    func showBalance(_ xem: Decimal) {
        addInvocation(.m_showBalance__xem(Parameter<Decimal>.value(`xem`)))
		let perform = methodPerformValue(.m_showBalance__xem(Parameter<Decimal>.value(`xem`))) as? (Decimal) -> Void
		perform?(`xem`)
    }

    func showBalanceError() {
        addInvocation(.m_showBalanceError)
		let perform = methodPerformValue(.m_showBalanceError) as? () -> Void
		perform?()
    }

    func showLocalCurrency(_ value: Decimal, _ unit: Currency) {
        addInvocation(.m_showLocalCurrency__value_unit(Parameter<Decimal>.value(`value`), Parameter<Currency>.value(`unit`)))
		let perform = methodPerformValue(.m_showLocalCurrency__value_unit(Parameter<Decimal>.value(`value`), Parameter<Currency>.value(`unit`))) as? (Decimal, Currency) -> Void
		perform?(`value`, `unit`)
    }

    func showLocalCurrencyError() {
        addInvocation(.m_showLocalCurrencyError)
		let perform = methodPerformValue(.m_showLocalCurrencyError) as? () -> Void
		perform?()
    }

    func showMosaicListLoading() {
        addInvocation(.m_showMosaicListLoading)
		let perform = methodPerformValue(.m_showMosaicListLoading) as? () -> Void
		perform?()
    }

    func showMosaics(_ mosaics: [MosaicDetail]) {
        addInvocation(.m_showMosaics__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_showMosaics__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`))) as? ([MosaicDetail]) -> Void
		perform?(`mosaics`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showBalanceLoading
        case m_showBalance__xem(Parameter<Decimal>)
        case m_showBalanceError
        case m_showLocalCurrency__value_unit(Parameter<Decimal>, Parameter<Currency>)
        case m_showLocalCurrencyError
        case m_showMosaicListLoading
        case m_showMosaics__mosaics(Parameter<[MosaicDetail]>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<BalanceDetailPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showBalanceLoading, .m_showBalanceLoading):
                return true 
            case (.m_showBalance__xem(let lhsXem), .m_showBalance__xem(let rhsXem)):
                guard Parameter.compare(lhs: lhsXem, rhs: rhsXem, with: matcher) else { return false } 
                return true 
            case (.m_showBalanceError, .m_showBalanceError):
                return true 
            case (.m_showLocalCurrency__value_unit(let lhsValue, let lhsUnit), .m_showLocalCurrency__value_unit(let rhsValue, let rhsUnit)):
                guard Parameter.compare(lhs: lhsValue, rhs: rhsValue, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsUnit, rhs: rhsUnit, with: matcher) else { return false } 
                return true 
            case (.m_showLocalCurrencyError, .m_showLocalCurrencyError):
                return true 
            case (.m_showMosaicListLoading, .m_showMosaicListLoading):
                return true 
            case (.m_showMosaics__mosaics(let lhsMosaics), .m_showMosaics__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<BalanceDetailPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showBalanceLoading: return 0
            case let .m_showBalance__xem(p0): return p0.intValue
            case .m_showBalanceError: return 0
            case let .m_showLocalCurrency__value_unit(p0, p1): return p0.intValue + p1.intValue
            case .m_showLocalCurrencyError: return 0
            case .m_showMosaicListLoading: return 0
            case let .m_showMosaics__mosaics(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: BalanceDetailPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showBalanceLoading() -> Verify { return Verify(method: .m_showBalanceLoading)}
        static func showBalance(_ xem: Parameter<Decimal>) -> Verify { return Verify(method: .m_showBalance__xem(`xem`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `xem` label")
		static func showBalance(xem: Parameter<Decimal>) -> Verify { return Verify(method: .m_showBalance__xem(`xem`))}
        static func showBalanceError() -> Verify { return Verify(method: .m_showBalanceError)}
        static func showLocalCurrency(_ value: Parameter<Decimal>, _ unit: Parameter<Currency>) -> Verify { return Verify(method: .m_showLocalCurrency__value_unit(`value`, `unit`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `value` label, remove `unit` label")
		static func showLocalCurrency(value: Parameter<Decimal>, unit: Parameter<Currency>) -> Verify { return Verify(method: .m_showLocalCurrency__value_unit(`value`, `unit`))}
        static func showLocalCurrencyError() -> Verify { return Verify(method: .m_showLocalCurrencyError)}
        static func showMosaicListLoading() -> Verify { return Verify(method: .m_showMosaicListLoading)}
        static func showMosaics(_ mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_showMosaics__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaics(mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_showMosaics__mosaics(`mosaics`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<BalanceDetailPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showBalanceLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showBalanceLoading, performs: perform)
        }
        static func showBalance(_ xem: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_showBalance__xem(`xem`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `xem` label")
		static func showBalance(xem: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_showBalance__xem(`xem`), performs: perform)
        }
        static func showBalanceError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showBalanceError, performs: perform)
        }
        static func showLocalCurrency(_ value: Parameter<Decimal>, _ unit: Parameter<Currency>, perform: @escaping (Decimal, Currency) -> Void) -> Perform {
            return Perform(method: .m_showLocalCurrency__value_unit(`value`, `unit`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `value` label, remove `unit` label")
		static func showLocalCurrency(value: Parameter<Decimal>, unit: Parameter<Currency>, perform: @escaping (Decimal, Currency) -> Void) -> Perform {
            return Perform(method: .m_showLocalCurrency__value_unit(`value`, `unit`), performs: perform)
        }
        static func showLocalCurrencyError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLocalCurrencyError, performs: perform)
        }
        static func showMosaicListLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showMosaicListLoading, performs: perform)
        }
        static func showMosaics(_ mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_showMosaics__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaics(mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_showMosaics__mosaics(`mosaics`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BalanceDetailWireframe
class BalanceDetailWireframeMock: BalanceDetailWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "BalanceDetailWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - BaseInteractorOutput
class BaseInteractorOutputMock: BaseInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BasePresentation
class BasePresentationMock: BasePresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BaseUseCase
class BaseUseCaseMock: BaseUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BaseView
class BaseViewMock: BaseView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - BaseWireframe
class BaseWireframeMock: BaseWireframe, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationDetailInteractorOutput
class DonationDetailInteractorOutputMock: DonationDetailInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationDetailPresentation
class DonationDetailPresentationMock: DonationDetailPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: DonationDetailView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "DonationDetailPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (DonationDetailView)?

    var interactor: DonationDetailUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "DonationDetailPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (DonationDetailUseCase)?

    var router: DonationDetailWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "DonationDetailPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (DonationDetailWireframe)?





    func didClickGithub() {
        addInvocation(.m_didClickGithub)
		let perform = methodPerformValue(.m_didClickGithub) as? () -> Void
		perform?()
    }

    func dicClickTwitter() {
        addInvocation(.m_dicClickTwitter)
		let perform = methodPerformValue(.m_dicClickTwitter) as? () -> Void
		perform?()
    }

    func didClickDonate() {
        addInvocation(.m_didClickDonate)
		let perform = methodPerformValue(.m_didClickDonate) as? () -> Void
		perform?()
    }

    func didClickGoPinSetting() {
        addInvocation(.m_didClickGoPinSetting)
		let perform = methodPerformValue(.m_didClickGoPinSetting) as? () -> Void
		perform?()
    }

    func didClickGoWalletSelect() {
        addInvocation(.m_didClickGoWalletSelect)
		let perform = methodPerformValue(.m_didClickGoWalletSelect) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickGithub
        case m_dicClickTwitter
        case m_didClickDonate
        case m_didClickGoPinSetting
        case m_didClickGoWalletSelect
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<DonationDetailView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<DonationDetailUseCase?>)
        case p_router_get
		case p_router_set(Parameter<DonationDetailWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickGithub, .m_didClickGithub):
                return true 
            case (.m_dicClickTwitter, .m_dicClickTwitter):
                return true 
            case (.m_didClickDonate, .m_didClickDonate):
                return true 
            case (.m_didClickGoPinSetting, .m_didClickGoPinSetting):
                return true 
            case (.m_didClickGoWalletSelect, .m_didClickGoWalletSelect):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<DonationDetailView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<DonationDetailUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<DonationDetailWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickGithub: return 0
            case .m_dicClickTwitter: return 0
            case .m_didClickDonate: return 0
            case .m_didClickGoPinSetting: return 0
            case .m_didClickGoWalletSelect: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: DonationDetailView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: DonationDetailUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: DonationDetailWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickGithub() -> Verify { return Verify(method: .m_didClickGithub)}
        static func dicClickTwitter() -> Verify { return Verify(method: .m_dicClickTwitter)}
        static func didClickDonate() -> Verify { return Verify(method: .m_didClickDonate)}
        static func didClickGoPinSetting() -> Verify { return Verify(method: .m_didClickGoPinSetting)}
        static func didClickGoWalletSelect() -> Verify { return Verify(method: .m_didClickGoWalletSelect)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<DonationDetailView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<DonationDetailUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<DonationDetailWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickGithub(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGithub, performs: perform)
        }
        static func dicClickTwitter(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_dicClickTwitter, performs: perform)
        }
        static func didClickDonate(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickDonate, performs: perform)
        }
        static func didClickGoPinSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGoPinSetting, performs: perform)
        }
        static func didClickGoWalletSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGoWalletSelect, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationDetailUseCase
class DonationDetailUseCaseMock: DonationDetailUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: DonationDetailInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "DonationDetailUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (DonationDetailInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<DonationDetailInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<DonationDetailInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: DonationDetailInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<DonationDetailInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationDetailView
class DonationDetailViewMock: DonationDetailView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: DonationDetailPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "DonationDetailViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (DonationDetailPresentation)?





    func showDeveloper(_ developer: Developer) {
        addInvocation(.m_showDeveloper__developer(Parameter<Developer>.value(`developer`)))
		let perform = methodPerformValue(.m_showDeveloper__developer(Parameter<Developer>.value(`developer`))) as? (Developer) -> Void
		perform?(`developer`)
    }

    func showNotSetPinError() {
        addInvocation(.m_showNotSetPinError)
		let perform = methodPerformValue(.m_showNotSetPinError) as? () -> Void
		perform?()
    }

    func showNotSelectWalletError() {
        addInvocation(.m_showNotSelectWalletError)
		let perform = methodPerformValue(.m_showNotSelectWalletError) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showDeveloper__developer(Parameter<Developer>)
        case m_showNotSetPinError
        case m_showNotSelectWalletError
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<DonationDetailPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showDeveloper__developer(let lhsDeveloper), .m_showDeveloper__developer(let rhsDeveloper)):
                guard Parameter.compare(lhs: lhsDeveloper, rhs: rhsDeveloper, with: matcher) else { return false } 
                return true 
            case (.m_showNotSetPinError, .m_showNotSetPinError):
                return true 
            case (.m_showNotSelectWalletError, .m_showNotSelectWalletError):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<DonationDetailPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showDeveloper__developer(p0): return p0.intValue
            case .m_showNotSetPinError: return 0
            case .m_showNotSelectWalletError: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: DonationDetailPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showDeveloper(_ developer: Parameter<Developer>) -> Verify { return Verify(method: .m_showDeveloper__developer(`developer`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func showDeveloper(developer: Parameter<Developer>) -> Verify { return Verify(method: .m_showDeveloper__developer(`developer`))}
        static func showNotSetPinError() -> Verify { return Verify(method: .m_showNotSetPinError)}
        static func showNotSelectWalletError() -> Verify { return Verify(method: .m_showNotSelectWalletError)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<DonationDetailPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showDeveloper(_ developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_showDeveloper__developer(`developer`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func showDeveloper(developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_showDeveloper__developer(`developer`), performs: perform)
        }
        static func showNotSetPinError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showNotSetPinError, performs: perform)
        }
        static func showNotSelectWalletError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showNotSelectWalletError, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationDetailWireframe
class DonationDetailWireframeMock: DonationDetailWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "DonationDetailWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ developer: Developer) -> UIViewController {
        addInvocation(.sm_assembleModule__developer(Parameter<Developer>.value(`developer`)))
		let perform = methodPerformValue(.sm_assembleModule__developer(Parameter<Developer>.value(`developer`))) as? (Developer) -> Void
		perform?(`developer`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__developer(Parameter<Developer>.value(`developer`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ developer: Developer). Use given")
		}
		return __value
    }

    func presentSendAmount(sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendAmount__sendTransaction_sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendAmount__sendTransaction_sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    func presentSetting() {
        addInvocation(.m_presentSetting)
		let perform = methodPerformValue(.m_presentSetting) as? () -> Void
		perform?()
    }

    func presentWalletSelect() {
        addInvocation(.m_presentWalletSelect)
		let perform = methodPerformValue(.m_presentWalletSelect) as? () -> Void
		perform?()
    }

    func openUrl(_ urlString: String) {
        addInvocation(.m_openUrl__urlString(Parameter<String>.value(`urlString`)))
		let perform = methodPerformValue(.m_openUrl__urlString(Parameter<String>.value(`urlString`))) as? (String) -> Void
		perform?(`urlString`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__developer(Parameter<Developer>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__developer(let lhsDeveloper), .sm_assembleModule__developer(let rhsDeveloper)):
                guard Parameter.compare(lhs: lhsDeveloper, rhs: rhsDeveloper, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__developer(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ developer: Parameter<Developer>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__developer(`developer`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func assembleModule(developer: Parameter<Developer>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__developer(`developer`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ developer: Parameter<Developer>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__developer(`developer`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ developer: Parameter<Developer>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__developer(`developer`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func assembleModule(developer: Parameter<Developer>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__developer(`developer`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__developer(`developer`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func assembleModule(developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__developer(`developer`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendAmount__sendTransaction_sendTransaction(Parameter<SendTransaction>)
        case m_presentSetting
        case m_presentWalletSelect
        case m_openUrl__urlString(Parameter<String>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendAmount__sendTransaction_sendTransaction(let lhsSendtransaction), .m_presentSendAmount__sendTransaction_sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.m_presentSetting, .m_presentSetting):
                return true 
            case (.m_presentWalletSelect, .m_presentWalletSelect):
                return true 
            case (.m_openUrl__urlString(let lhsUrlstring), .m_openUrl__urlString(let rhsUrlstring)):
                guard Parameter.compare(lhs: lhsUrlstring, rhs: rhsUrlstring, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentSendAmount__sendTransaction_sendTransaction(p0): return p0.intValue
            case .m_presentSetting: return 0
            case .m_presentWalletSelect: return 0
            case let .m_openUrl__urlString(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendAmount(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendAmount__sendTransaction_sendTransaction(`sendTransaction`))}
        static func presentSetting() -> Verify { return Verify(method: .m_presentSetting)}
        static func presentWalletSelect() -> Verify { return Verify(method: .m_presentWalletSelect)}
        static func openUrl(_ urlString: Parameter<String>) -> Verify { return Verify(method: .m_openUrl__urlString(`urlString`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `urlString` label")
		static func openUrl(urlString: Parameter<String>) -> Verify { return Verify(method: .m_openUrl__urlString(`urlString`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendAmount(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendAmount__sendTransaction_sendTransaction(`sendTransaction`), performs: perform)
        }
        static func presentSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSetting, performs: perform)
        }
        static func presentWalletSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentWalletSelect, performs: perform)
        }
        static func openUrl(_ urlString: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_openUrl__urlString(`urlString`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `urlString` label")
		static func openUrl(urlString: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_openUrl__urlString(`urlString`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - DonationTopInteractorOutput
class DonationTopInteractorOutputMock: DonationTopInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationTopPresentation
class DonationTopPresentationMock: DonationTopPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: DonationTopView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "DonationTopPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (DonationTopView)?

    var interactor: DonationTopUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "DonationTopPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (DonationTopUseCase)?

    var router: DonationTopWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "DonationTopPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (DonationTopWireframe)?





    func didClickDeveloper(_ developer: Developer) {
        addInvocation(.m_didClickDeveloper__developer(Parameter<Developer>.value(`developer`)))
		let perform = methodPerformValue(.m_didClickDeveloper__developer(Parameter<Developer>.value(`developer`))) as? (Developer) -> Void
		perform?(`developer`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickDeveloper__developer(Parameter<Developer>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<DonationTopView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<DonationTopUseCase?>)
        case p_router_get
		case p_router_set(Parameter<DonationTopWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickDeveloper__developer(let lhsDeveloper), .m_didClickDeveloper__developer(let rhsDeveloper)):
                guard Parameter.compare(lhs: lhsDeveloper, rhs: rhsDeveloper, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<DonationTopView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<DonationTopUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<DonationTopWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didClickDeveloper__developer(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: DonationTopView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: DonationTopUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: DonationTopWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickDeveloper(_ developer: Parameter<Developer>) -> Verify { return Verify(method: .m_didClickDeveloper__developer(`developer`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func didClickDeveloper(developer: Parameter<Developer>) -> Verify { return Verify(method: .m_didClickDeveloper__developer(`developer`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<DonationTopView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<DonationTopUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<DonationTopWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickDeveloper(_ developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_didClickDeveloper__developer(`developer`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func didClickDeveloper(developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_didClickDeveloper__developer(`developer`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationTopUseCase
class DonationTopUseCaseMock: DonationTopUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: DonationTopInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "DonationTopUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (DonationTopInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<DonationTopInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<DonationTopInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: DonationTopInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<DonationTopInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationTopView
class DonationTopViewMock: DonationTopView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: DonationTopPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "DonationTopViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (DonationTopPresentation)?





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<DonationTopPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<DonationTopPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: DonationTopPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<DonationTopPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - DonationTopWireframe
class DonationTopWireframeMock: DonationTopWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "DonationTopWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentDonationDetail(_ developer: Developer) {
        addInvocation(.m_presentDonationDetail__developer(Parameter<Developer>.value(`developer`)))
		let perform = methodPerformValue(.m_presentDonationDetail__developer(Parameter<Developer>.value(`developer`))) as? (Developer) -> Void
		perform?(`developer`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentDonationDetail__developer(Parameter<Developer>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentDonationDetail__developer(let lhsDeveloper), .m_presentDonationDetail__developer(let rhsDeveloper)):
                guard Parameter.compare(lhs: lhsDeveloper, rhs: rhsDeveloper, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentDonationDetail__developer(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentDonationDetail(_ developer: Parameter<Developer>) -> Verify { return Verify(method: .m_presentDonationDetail__developer(`developer`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func presentDonationDetail(developer: Parameter<Developer>) -> Verify { return Verify(method: .m_presentDonationDetail__developer(`developer`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentDonationDetail(_ developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_presentDonationDetail__developer(`developer`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `developer` label")
		static func presentDonationDetail(developer: Parameter<Developer>, perform: @escaping (Developer) -> Void) -> Perform {
            return Perform(method: .m_presentDonationDetail__developer(`developer`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - IntroductionConceptInteractorOutput
class IntroductionConceptInteractorOutputMock: IntroductionConceptInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionConceptPresentation
class IntroductionConceptPresentationMock: IntroductionConceptPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: IntroductionConceptView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "IntroductionConceptPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (IntroductionConceptView)?

    var interactor: IntroductionConceptUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "IntroductionConceptPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (IntroductionConceptUseCase)?

    var router: IntroductionConceptWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "IntroductionConceptPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (IntroductionConceptWireframe)?





    func didChangePage(_ page: Int) {
        addInvocation(.m_didChangePage__page(Parameter<Int>.value(`page`)))
		let perform = methodPerformValue(.m_didChangePage__page(Parameter<Int>.value(`page`))) as? (Int) -> Void
		perform?(`page`)
    }

    func didClickGetStarted() {
        addInvocation(.m_didClickGetStarted)
		let perform = methodPerformValue(.m_didClickGetStarted) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didChangePage__page(Parameter<Int>)
        case m_didClickGetStarted
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<IntroductionConceptView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<IntroductionConceptUseCase?>)
        case p_router_get
		case p_router_set(Parameter<IntroductionConceptWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didChangePage__page(let lhsPage), .m_didChangePage__page(let rhsPage)):
                guard Parameter.compare(lhs: lhsPage, rhs: rhsPage, with: matcher) else { return false } 
                return true 
            case (.m_didClickGetStarted, .m_didClickGetStarted):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<IntroductionConceptView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<IntroductionConceptUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<IntroductionConceptWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didChangePage__page(p0): return p0.intValue
            case .m_didClickGetStarted: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: IntroductionConceptView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: IntroductionConceptUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: IntroductionConceptWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didChangePage(_ page: Parameter<Int>) -> Verify { return Verify(method: .m_didChangePage__page(`page`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `page` label")
		static func didChangePage(page: Parameter<Int>) -> Verify { return Verify(method: .m_didChangePage__page(`page`))}
        static func didClickGetStarted() -> Verify { return Verify(method: .m_didClickGetStarted)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<IntroductionConceptView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<IntroductionConceptUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<IntroductionConceptWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didChangePage(_ page: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didChangePage__page(`page`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `page` label")
		static func didChangePage(page: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didChangePage__page(`page`), performs: perform)
        }
        static func didClickGetStarted(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGetStarted, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionConceptUseCase
class IntroductionConceptUseCaseMock: IntroductionConceptUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: IntroductionConceptInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "IntroductionConceptUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (IntroductionConceptInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<IntroductionConceptInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<IntroductionConceptInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: IntroductionConceptInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<IntroductionConceptInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionConceptView
class IntroductionConceptViewMock: IntroductionConceptView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: IntroductionConceptPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "IntroductionConceptViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (IntroductionConceptPresentation)?





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<IntroductionConceptPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<IntroductionConceptPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: IntroductionConceptPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<IntroductionConceptPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionConceptWireframe
class IntroductionConceptWireframeMock: IntroductionConceptWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "IntroductionConceptWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentIntroductionMessage() {
        addInvocation(.m_presentIntroductionMessage)
		let perform = methodPerformValue(.m_presentIntroductionMessage) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentIntroductionMessage
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentIntroductionMessage, .m_presentIntroductionMessage):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentIntroductionMessage: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentIntroductionMessage() -> Verify { return Verify(method: .m_presentIntroductionMessage)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentIntroductionMessage(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentIntroductionMessage, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - IntroductionMessageInteractorOutput
class IntroductionMessageInteractorOutputMock: IntroductionMessageInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionMessagePresentation
class IntroductionMessagePresentationMock: IntroductionMessagePresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: IntroductionMessageView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "IntroductionMessagePresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (IntroductionMessageView)?

    var interactor: IntroductionMessageUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "IntroductionMessagePresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (IntroductionMessageUseCase)?

    var router: IntroductionMessageWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "IntroductionMessagePresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (IntroductionMessageWireframe)?





    func didClickOk() {
        addInvocation(.m_didClickOk)
		let perform = methodPerformValue(.m_didClickOk) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickOk
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<IntroductionMessageView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<IntroductionMessageUseCase?>)
        case p_router_get
		case p_router_set(Parameter<IntroductionMessageWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickOk, .m_didClickOk):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<IntroductionMessageView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<IntroductionMessageUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<IntroductionMessageWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickOk: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: IntroductionMessageView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: IntroductionMessageUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: IntroductionMessageWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickOk() -> Verify { return Verify(method: .m_didClickOk)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<IntroductionMessageView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<IntroductionMessageUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<IntroductionMessageWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickOk(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOk, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionMessageUseCase
class IntroductionMessageUseCaseMock: IntroductionMessageUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: IntroductionMessageInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "IntroductionMessageUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (IntroductionMessageInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<IntroductionMessageInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<IntroductionMessageInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: IntroductionMessageInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<IntroductionMessageInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionMessageView
class IntroductionMessageViewMock: IntroductionMessageView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: IntroductionMessagePresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "IntroductionMessageViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (IntroductionMessagePresentation)?





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<IntroductionMessagePresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<IntroductionMessagePresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: IntroductionMessagePresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<IntroductionMessagePresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - IntroductionMessageWireframe
class IntroductionMessageWireframeMock: IntroductionMessageWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "IntroductionMessageWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentCreateWallet() {
        addInvocation(.m_presentCreateWallet)
		let perform = methodPerformValue(.m_presentCreateWallet) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentCreateWallet
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentCreateWallet, .m_presentCreateWallet):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentCreateWallet: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentCreateWallet() -> Verify { return Verify(method: .m_presentCreateWallet)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentCreateWallet(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentCreateWallet, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - MosaicDetailInteractorOutput
class MosaicDetailInteractorOutputMock: MosaicDetailInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicDetailPresentation
class MosaicDetailPresentationMock: MosaicDetailPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: MosaicDetailView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "MosaicDetailPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (MosaicDetailView)?

    var interactor: MosaicDetailUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "MosaicDetailPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (MosaicDetailUseCase)?

    var router: MosaicDetailWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "MosaicDetailPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (MosaicDetailWireframe)?





    func didClickOutside() {
        addInvocation(.m_didClickOutside)
		let perform = methodPerformValue(.m_didClickOutside) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickOutside
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<MosaicDetailView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<MosaicDetailUseCase?>)
        case p_router_get
		case p_router_set(Parameter<MosaicDetailWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickOutside, .m_didClickOutside):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<MosaicDetailView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<MosaicDetailUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<MosaicDetailWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickOutside: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: MosaicDetailView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: MosaicDetailUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: MosaicDetailWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickOutside() -> Verify { return Verify(method: .m_didClickOutside)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<MosaicDetailView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<MosaicDetailUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<MosaicDetailWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickOutside(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOutside, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicDetailUseCase
class MosaicDetailUseCaseMock: MosaicDetailUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: MosaicDetailInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "MosaicDetailUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (MosaicDetailInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<MosaicDetailInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<MosaicDetailInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: MosaicDetailInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<MosaicDetailInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicDetailView
class MosaicDetailViewMock: MosaicDetailView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: MosaicDetailPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "MosaicDetailViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (MosaicDetailPresentation)?





    func showImage(_ url: URL) {
        addInvocation(.m_showImage__url(Parameter<URL>.value(`url`)))
		let perform = methodPerformValue(.m_showImage__url(Parameter<URL>.value(`url`))) as? (URL) -> Void
		perform?(`url`)
    }

    func showText(_ namespace: String, _ name: String) {
        addInvocation(.m_showText__namespace_name(Parameter<String>.value(`namespace`), Parameter<String>.value(`name`)))
		let perform = methodPerformValue(.m_showText__namespace_name(Parameter<String>.value(`namespace`), Parameter<String>.value(`name`))) as? (String, String) -> Void
		perform?(`namespace`, `name`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showImage__url(Parameter<URL>)
        case m_showText__namespace_name(Parameter<String>, Parameter<String>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<MosaicDetailPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showImage__url(let lhsUrl), .m_showImage__url(let rhsUrl)):
                guard Parameter.compare(lhs: lhsUrl, rhs: rhsUrl, with: matcher) else { return false } 
                return true 
            case (.m_showText__namespace_name(let lhsNamespace, let lhsName), .m_showText__namespace_name(let rhsNamespace, let rhsName)):
                guard Parameter.compare(lhs: lhsNamespace, rhs: rhsNamespace, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsName, rhs: rhsName, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<MosaicDetailPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showImage__url(p0): return p0.intValue
            case let .m_showText__namespace_name(p0, p1): return p0.intValue + p1.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: MosaicDetailPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showImage(_ url: Parameter<URL>) -> Verify { return Verify(method: .m_showImage__url(`url`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `url` label")
		static func showImage(url: Parameter<URL>) -> Verify { return Verify(method: .m_showImage__url(`url`))}
        static func showText(_ namespace: Parameter<String>, _ name: Parameter<String>) -> Verify { return Verify(method: .m_showText__namespace_name(`namespace`, `name`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `namespace` label, remove `name` label")
		static func showText(namespace: Parameter<String>, name: Parameter<String>) -> Verify { return Verify(method: .m_showText__namespace_name(`namespace`, `name`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<MosaicDetailPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showImage(_ url: Parameter<URL>, perform: @escaping (URL) -> Void) -> Perform {
            return Perform(method: .m_showImage__url(`url`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `url` label")
		static func showImage(url: Parameter<URL>, perform: @escaping (URL) -> Void) -> Perform {
            return Perform(method: .m_showImage__url(`url`), performs: perform)
        }
        static func showText(_ namespace: Parameter<String>, _ name: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_showText__namespace_name(`namespace`, `name`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `namespace` label, remove `name` label")
		static func showText(namespace: Parameter<String>, name: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_showText__namespace_name(`namespace`, `name`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicDetailWireframe
class MosaicDetailWireframeMock: MosaicDetailWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "MosaicDetailWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ mosaic: MosaicImageUrl) -> UIViewController {
        addInvocation(.sm_assembleModule__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`)))
		let perform = methodPerformValue(.sm_assembleModule__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`))) as? (MosaicImageUrl) -> Void
		perform?(`mosaic`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ mosaic: MosaicImageUrl). Use given")
		}
		return __value
    }

    func dismiss() {
        addInvocation(.m_dismiss)
		let perform = methodPerformValue(.m_dismiss) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__mosaic(Parameter<MosaicImageUrl>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__mosaic(let lhsMosaic), .sm_assembleModule__mosaic(let rhsMosaic)):
                guard Parameter.compare(lhs: lhsMosaic, rhs: rhsMosaic, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__mosaic(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ mosaic: Parameter<MosaicImageUrl>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__mosaic(`mosaic`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func assembleModule(mosaic: Parameter<MosaicImageUrl>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__mosaic(`mosaic`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ mosaic: Parameter<MosaicImageUrl>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__mosaic(`mosaic`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ mosaic: Parameter<MosaicImageUrl>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__mosaic(`mosaic`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func assembleModule(mosaic: Parameter<MosaicImageUrl>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__mosaic(`mosaic`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__mosaic(`mosaic`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func assembleModule(mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__mosaic(`mosaic`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_dismiss
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_dismiss, .m_dismiss):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_dismiss: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func dismiss() -> Verify { return Verify(method: .m_dismiss)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func dismiss(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_dismiss, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - MosaicListInteractorOutput
class MosaicListInteractorOutputMock: MosaicListInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func mosaicListFetched(_ mosaics: [MosaicImageUrl]) {
        addInvocation(.m_mosaicListFetched__mosaics(Parameter<[MosaicImageUrl]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_mosaicListFetched__mosaics(Parameter<[MosaicImageUrl]>.value(`mosaics`))) as? ([MosaicImageUrl]) -> Void
		perform?(`mosaics`)
    }

    func mosaicListFetchFailed(_ error: Error) {
        addInvocation(.m_mosaicListFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_mosaicListFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    func mosaicOwnedFetched(_ mosaics: [MosaicDetail]) {
        addInvocation(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`))) as? ([MosaicDetail]) -> Void
		perform?(`mosaics`)
    }

    func mosaicOwnedFetchFailed(_ error: Error) {
        addInvocation(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_mosaicListFetched__mosaics(Parameter<[MosaicImageUrl]>)
        case m_mosaicListFetchFailed__error(Parameter<Error>)
        case m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>)
        case m_mosaicOwnedFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_mosaicListFetched__mosaics(let lhsMosaics), .m_mosaicListFetched__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_mosaicListFetchFailed__error(let lhsError), .m_mosaicListFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_mosaicOwnedFetched__mosaics(let lhsMosaics), .m_mosaicOwnedFetched__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_mosaicOwnedFetchFailed__error(let lhsError), .m_mosaicOwnedFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_mosaicListFetched__mosaics(p0): return p0.intValue
            case let .m_mosaicListFetchFailed__error(p0): return p0.intValue
            case let .m_mosaicOwnedFetched__mosaics(p0): return p0.intValue
            case let .m_mosaicOwnedFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func mosaicListFetched(_ mosaics: Parameter<[MosaicImageUrl]>) -> Verify { return Verify(method: .m_mosaicListFetched__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicListFetched(mosaics: Parameter<[MosaicImageUrl]>) -> Verify { return Verify(method: .m_mosaicListFetched__mosaics(`mosaics`))}
        static func mosaicListFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicListFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicListFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicListFetchFailed__error(`error`))}
        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func mosaicListFetched(_ mosaics: Parameter<[MosaicImageUrl]>, perform: @escaping ([MosaicImageUrl]) -> Void) -> Perform {
            return Perform(method: .m_mosaicListFetched__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicListFetched(mosaics: Parameter<[MosaicImageUrl]>, perform: @escaping ([MosaicImageUrl]) -> Void) -> Perform {
            return Perform(method: .m_mosaicListFetched__mosaics(`mosaics`), performs: perform)
        }
        static func mosaicListFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicListFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicListFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicListFetchFailed__error(`error`), performs: perform)
        }
        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicListPresentation
class MosaicListPresentationMock: MosaicListPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: MosaicListView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "MosaicListPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (MosaicListView)?

    var interactor: MosaicListUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "MosaicListPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (MosaicListUseCase)?

    var router: MosaicListWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "MosaicListPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (MosaicListWireframe)?





    func didClickMosaic(_ mosaic: MosaicImageUrl) {
        addInvocation(.m_didClickMosaic__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`)))
		let perform = methodPerformValue(.m_didClickMosaic__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`))) as? (MosaicImageUrl) -> Void
		perform?(`mosaic`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickMosaic__mosaic(Parameter<MosaicImageUrl>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<MosaicListView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<MosaicListUseCase?>)
        case p_router_get
		case p_router_set(Parameter<MosaicListWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickMosaic__mosaic(let lhsMosaic), .m_didClickMosaic__mosaic(let rhsMosaic)):
                guard Parameter.compare(lhs: lhsMosaic, rhs: rhsMosaic, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<MosaicListView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<MosaicListUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<MosaicListWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didClickMosaic__mosaic(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: MosaicListView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: MosaicListUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: MosaicListWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickMosaic(_ mosaic: Parameter<MosaicImageUrl>) -> Verify { return Verify(method: .m_didClickMosaic__mosaic(`mosaic`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didClickMosaic(mosaic: Parameter<MosaicImageUrl>) -> Verify { return Verify(method: .m_didClickMosaic__mosaic(`mosaic`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<MosaicListView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<MosaicListUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<MosaicListWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickMosaic(_ mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> Perform {
            return Perform(method: .m_didClickMosaic__mosaic(`mosaic`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didClickMosaic(mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> Perform {
            return Perform(method: .m_didClickMosaic__mosaic(`mosaic`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicListUseCase
class MosaicListUseCaseMock: MosaicListUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: MosaicListInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "MosaicListUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (MosaicListInteractorOutput)?





    func fetchMosaicOwned(_ address: String) {
        addInvocation(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }

    func fetchXEMBookMosaicList() {
        addInvocation(.m_fetchXEMBookMosaicList)
		let perform = methodPerformValue(.m_fetchXEMBookMosaicList) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_fetchMosaicOwned__address(Parameter<String>)
        case m_fetchXEMBookMosaicList
        case p_output_get
		case p_output_set(Parameter<MosaicListInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchMosaicOwned__address(let lhsAddress), .m_fetchMosaicOwned__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.m_fetchXEMBookMosaicList, .m_fetchXEMBookMosaicList):
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<MosaicListInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchMosaicOwned__address(p0): return p0.intValue
            case .m_fetchXEMBookMosaicList: return 0
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: MosaicListInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchMosaicOwned(_ address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        static func fetchXEMBookMosaicList() -> Verify { return Verify(method: .m_fetchXEMBookMosaicList)}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<MosaicListInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchMosaicOwned(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        static func fetchXEMBookMosaicList(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_fetchXEMBookMosaicList, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicListView
class MosaicListViewMock: MosaicListView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: MosaicListPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "MosaicListViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (MosaicListPresentation)?





    func showLoading() {
        addInvocation(.m_showLoading)
		let perform = methodPerformValue(.m_showLoading) as? () -> Void
		perform?()
    }

    func hideLoading() {
        addInvocation(.m_hideLoading)
		let perform = methodPerformValue(.m_hideLoading) as? () -> Void
		perform?()
    }

    func showEmpty() {
        addInvocation(.m_showEmpty)
		let perform = methodPerformValue(.m_showEmpty) as? () -> Void
		perform?()
    }

    func showMosaics(_ mosaics: [MosaicImageUrl]) {
        addInvocation(.m_showMosaics__mosaics(Parameter<[MosaicImageUrl]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_showMosaics__mosaics(Parameter<[MosaicImageUrl]>.value(`mosaics`))) as? ([MosaicImageUrl]) -> Void
		perform?(`mosaics`)
    }

    func showMosaicDetail(_ mosaic: MosaicImageUrl) {
        addInvocation(.m_showMosaicDetail__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`)))
		let perform = methodPerformValue(.m_showMosaicDetail__mosaic(Parameter<MosaicImageUrl>.value(`mosaic`))) as? (MosaicImageUrl) -> Void
		perform?(`mosaic`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showLoading
        case m_hideLoading
        case m_showEmpty
        case m_showMosaics__mosaics(Parameter<[MosaicImageUrl]>)
        case m_showMosaicDetail__mosaic(Parameter<MosaicImageUrl>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<MosaicListPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showLoading, .m_showLoading):
                return true 
            case (.m_hideLoading, .m_hideLoading):
                return true 
            case (.m_showEmpty, .m_showEmpty):
                return true 
            case (.m_showMosaics__mosaics(let lhsMosaics), .m_showMosaics__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_showMosaicDetail__mosaic(let lhsMosaic), .m_showMosaicDetail__mosaic(let rhsMosaic)):
                guard Parameter.compare(lhs: lhsMosaic, rhs: rhsMosaic, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<MosaicListPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showLoading: return 0
            case .m_hideLoading: return 0
            case .m_showEmpty: return 0
            case let .m_showMosaics__mosaics(p0): return p0.intValue
            case let .m_showMosaicDetail__mosaic(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: MosaicListPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showLoading() -> Verify { return Verify(method: .m_showLoading)}
        static func hideLoading() -> Verify { return Verify(method: .m_hideLoading)}
        static func showEmpty() -> Verify { return Verify(method: .m_showEmpty)}
        static func showMosaics(_ mosaics: Parameter<[MosaicImageUrl]>) -> Verify { return Verify(method: .m_showMosaics__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaics(mosaics: Parameter<[MosaicImageUrl]>) -> Verify { return Verify(method: .m_showMosaics__mosaics(`mosaics`))}
        static func showMosaicDetail(_ mosaic: Parameter<MosaicImageUrl>) -> Verify { return Verify(method: .m_showMosaicDetail__mosaic(`mosaic`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func showMosaicDetail(mosaic: Parameter<MosaicImageUrl>) -> Verify { return Verify(method: .m_showMosaicDetail__mosaic(`mosaic`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<MosaicListPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoading, performs: perform)
        }
        static func hideLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideLoading, performs: perform)
        }
        static func showEmpty(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showEmpty, performs: perform)
        }
        static func showMosaics(_ mosaics: Parameter<[MosaicImageUrl]>, perform: @escaping ([MosaicImageUrl]) -> Void) -> Perform {
            return Perform(method: .m_showMosaics__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaics(mosaics: Parameter<[MosaicImageUrl]>, perform: @escaping ([MosaicImageUrl]) -> Void) -> Perform {
            return Perform(method: .m_showMosaics__mosaics(`mosaics`), performs: perform)
        }
        static func showMosaicDetail(_ mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> Perform {
            return Perform(method: .m_showMosaicDetail__mosaic(`mosaic`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func showMosaicDetail(mosaic: Parameter<MosaicImageUrl>, perform: @escaping (MosaicImageUrl) -> Void) -> Perform {
            return Perform(method: .m_showMosaicDetail__mosaic(`mosaic`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - MosaicListWireframe
class MosaicListWireframeMock: MosaicListWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "MosaicListWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - NavigationDrawerInteractorOutput
class NavigationDrawerInteractorOutputMock: NavigationDrawerInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NavigationDrawerPresentation
class NavigationDrawerPresentationMock: NavigationDrawerPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: NavigationDrawerView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "NavigationDrawerPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (NavigationDrawerView)?

    var interactor: NavigationDrawerUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "NavigationDrawerPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (NavigationDrawerUseCase)?

    var router: NavigationDrawerWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "NavigationDrawerPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (NavigationDrawerWireframe)?





    func didClickHome() {
        addInvocation(.m_didClickHome)
		let perform = methodPerformValue(.m_didClickHome) as? () -> Void
		perform?()
    }

    func didClickAddressBook() {
        addInvocation(.m_didClickAddressBook)
		let perform = methodPerformValue(.m_didClickAddressBook) as? () -> Void
		perform?()
    }

    func didClickGallery() {
        addInvocation(.m_didClickGallery)
		let perform = methodPerformValue(.m_didClickGallery) as? () -> Void
		perform?()
    }

    func didClickDonation() {
        addInvocation(.m_didClickDonation)
		let perform = methodPerformValue(.m_didClickDonation) as? () -> Void
		perform?()
    }

    func didClickAbout() {
        addInvocation(.m_didClickAbout)
		let perform = methodPerformValue(.m_didClickAbout) as? () -> Void
		perform?()
    }

    func didClickHelp() {
        addInvocation(.m_didClickHelp)
		let perform = methodPerformValue(.m_didClickHelp) as? () -> Void
		perform?()
    }

    func didClickSetting() {
        addInvocation(.m_didClickSetting)
		let perform = methodPerformValue(.m_didClickSetting) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickHome
        case m_didClickAddressBook
        case m_didClickGallery
        case m_didClickDonation
        case m_didClickAbout
        case m_didClickHelp
        case m_didClickSetting
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<NavigationDrawerView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<NavigationDrawerUseCase?>)
        case p_router_get
		case p_router_set(Parameter<NavigationDrawerWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickHome, .m_didClickHome):
                return true 
            case (.m_didClickAddressBook, .m_didClickAddressBook):
                return true 
            case (.m_didClickGallery, .m_didClickGallery):
                return true 
            case (.m_didClickDonation, .m_didClickDonation):
                return true 
            case (.m_didClickAbout, .m_didClickAbout):
                return true 
            case (.m_didClickHelp, .m_didClickHelp):
                return true 
            case (.m_didClickSetting, .m_didClickSetting):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<NavigationDrawerView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<NavigationDrawerUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<NavigationDrawerWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickHome: return 0
            case .m_didClickAddressBook: return 0
            case .m_didClickGallery: return 0
            case .m_didClickDonation: return 0
            case .m_didClickAbout: return 0
            case .m_didClickHelp: return 0
            case .m_didClickSetting: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: NavigationDrawerView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: NavigationDrawerUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: NavigationDrawerWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickHome() -> Verify { return Verify(method: .m_didClickHome)}
        static func didClickAddressBook() -> Verify { return Verify(method: .m_didClickAddressBook)}
        static func didClickGallery() -> Verify { return Verify(method: .m_didClickGallery)}
        static func didClickDonation() -> Verify { return Verify(method: .m_didClickDonation)}
        static func didClickAbout() -> Verify { return Verify(method: .m_didClickAbout)}
        static func didClickHelp() -> Verify { return Verify(method: .m_didClickHelp)}
        static func didClickSetting() -> Verify { return Verify(method: .m_didClickSetting)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<NavigationDrawerView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<NavigationDrawerUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<NavigationDrawerWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickHome(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickHome, performs: perform)
        }
        static func didClickAddressBook(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickAddressBook, performs: perform)
        }
        static func didClickGallery(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGallery, performs: perform)
        }
        static func didClickDonation(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickDonation, performs: perform)
        }
        static func didClickAbout(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickAbout, performs: perform)
        }
        static func didClickHelp(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickHelp, performs: perform)
        }
        static func didClickSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickSetting, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NavigationDrawerUseCase
class NavigationDrawerUseCaseMock: NavigationDrawerUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: NavigationDrawerInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "NavigationDrawerUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (NavigationDrawerInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<NavigationDrawerInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<NavigationDrawerInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: NavigationDrawerInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<NavigationDrawerInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NavigationDrawerView
class NavigationDrawerViewMock: NavigationDrawerView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: NavigationDrawerPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "NavigationDrawerViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (NavigationDrawerPresentation)?





    func showName(_ name: String) {
        addInvocation(.m_showName__name(Parameter<String>.value(`name`)))
		let perform = methodPerformValue(.m_showName__name(Parameter<String>.value(`name`))) as? (String) -> Void
		perform?(`name`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showName__name(Parameter<String>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<NavigationDrawerPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showName__name(let lhsName), .m_showName__name(let rhsName)):
                guard Parameter.compare(lhs: lhsName, rhs: rhsName, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<NavigationDrawerPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showName__name(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: NavigationDrawerPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showName(_ name: Parameter<String>) -> Verify { return Verify(method: .m_showName__name(`name`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `name` label")
		static func showName(name: Parameter<String>) -> Verify { return Verify(method: .m_showName__name(`name`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<NavigationDrawerPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showName(_ name: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showName__name(`name`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `name` label")
		static func showName(name: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showName__name(`name`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NavigationDrawerWireframe
class NavigationDrawerWireframeMock: NavigationDrawerWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "NavigationDrawerWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentHome() {
        addInvocation(.m_presentHome)
		let perform = methodPerformValue(.m_presentHome) as? () -> Void
		perform?()
    }

    func presentAddressBook() {
        addInvocation(.m_presentAddressBook)
		let perform = methodPerformValue(.m_presentAddressBook) as? () -> Void
		perform?()
    }

    func presentGallery() {
        addInvocation(.m_presentGallery)
		let perform = methodPerformValue(.m_presentGallery) as? () -> Void
		perform?()
    }

    func presentDonation() {
        addInvocation(.m_presentDonation)
		let perform = methodPerformValue(.m_presentDonation) as? () -> Void
		perform?()
    }

    func presentAbout() {
        addInvocation(.m_presentAbout)
		let perform = methodPerformValue(.m_presentAbout) as? () -> Void
		perform?()
    }

    func presentHelp() {
        addInvocation(.m_presentHelp)
		let perform = methodPerformValue(.m_presentHelp) as? () -> Void
		perform?()
    }

    func presentSetting() {
        addInvocation(.m_presentSetting)
		let perform = methodPerformValue(.m_presentSetting) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentHome
        case m_presentAddressBook
        case m_presentGallery
        case m_presentDonation
        case m_presentAbout
        case m_presentHelp
        case m_presentSetting
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentHome, .m_presentHome):
                return true 
            case (.m_presentAddressBook, .m_presentAddressBook):
                return true 
            case (.m_presentGallery, .m_presentGallery):
                return true 
            case (.m_presentDonation, .m_presentDonation):
                return true 
            case (.m_presentAbout, .m_presentAbout):
                return true 
            case (.m_presentHelp, .m_presentHelp):
                return true 
            case (.m_presentSetting, .m_presentSetting):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentHome: return 0
            case .m_presentAddressBook: return 0
            case .m_presentGallery: return 0
            case .m_presentDonation: return 0
            case .m_presentAbout: return 0
            case .m_presentHelp: return 0
            case .m_presentSetting: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentHome() -> Verify { return Verify(method: .m_presentHome)}
        static func presentAddressBook() -> Verify { return Verify(method: .m_presentAddressBook)}
        static func presentGallery() -> Verify { return Verify(method: .m_presentGallery)}
        static func presentDonation() -> Verify { return Verify(method: .m_presentDonation)}
        static func presentAbout() -> Verify { return Verify(method: .m_presentAbout)}
        static func presentHelp() -> Verify { return Verify(method: .m_presentHelp)}
        static func presentSetting() -> Verify { return Verify(method: .m_presentSetting)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentHome(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentHome, performs: perform)
        }
        static func presentAddressBook(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentAddressBook, performs: perform)
        }
        static func presentGallery(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentGallery, performs: perform)
        }
        static func presentDonation(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentDonation, performs: perform)
        }
        static func presentAbout(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentAbout, performs: perform)
        }
        static func presentHelp(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentHelp, performs: perform)
        }
        static func presentSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSetting, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - NodeSelectInteractorOutput
class NodeSelectInteractorOutputMock: NodeSelectInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func nodesFetched(_ nodes: [NemNode]) {
        addInvocation(.m_nodesFetched__nodes(Parameter<[NemNode]>.value(`nodes`)))
		let perform = methodPerformValue(.m_nodesFetched__nodes(Parameter<[NemNode]>.value(`nodes`))) as? ([NemNode]) -> Void
		perform?(`nodes`)
    }

    func nodesFetchFailed(_ error: Error) {
        addInvocation(.m_nodesFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_nodesFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_nodesFetched__nodes(Parameter<[NemNode]>)
        case m_nodesFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_nodesFetched__nodes(let lhsNodes), .m_nodesFetched__nodes(let rhsNodes)):
                guard Parameter.compare(lhs: lhsNodes, rhs: rhsNodes, with: matcher) else { return false } 
                return true 
            case (.m_nodesFetchFailed__error(let lhsError), .m_nodesFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_nodesFetched__nodes(p0): return p0.intValue
            case let .m_nodesFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func nodesFetched(_ nodes: Parameter<[NemNode]>) -> Verify { return Verify(method: .m_nodesFetched__nodes(`nodes`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `nodes` label")
		static func nodesFetched(nodes: Parameter<[NemNode]>) -> Verify { return Verify(method: .m_nodesFetched__nodes(`nodes`))}
        static func nodesFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_nodesFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func nodesFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_nodesFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func nodesFetched(_ nodes: Parameter<[NemNode]>, perform: @escaping ([NemNode]) -> Void) -> Perform {
            return Perform(method: .m_nodesFetched__nodes(`nodes`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `nodes` label")
		static func nodesFetched(nodes: Parameter<[NemNode]>, perform: @escaping ([NemNode]) -> Void) -> Perform {
            return Perform(method: .m_nodesFetched__nodes(`nodes`), performs: perform)
        }
        static func nodesFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_nodesFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func nodesFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_nodesFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NodeSelectPresentation
class NodeSelectPresentationMock: NodeSelectPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: NodeSelectView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "NodeSelectPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (NodeSelectView)?

    var interactor: NodeSelectUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "NodeSelectPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (NodeSelectUseCase)?

    var router: NodeSelectWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "NodeSelectPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (NodeSelectWireframe)?





    func didSelectNode(_ node: NemNode) {
        addInvocation(.m_didSelectNode__node(Parameter<NemNode>.value(`node`)))
		let perform = methodPerformValue(.m_didSelectNode__node(Parameter<NemNode>.value(`node`))) as? (NemNode) -> Void
		perform?(`node`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didSelectNode__node(Parameter<NemNode>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<NodeSelectView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<NodeSelectUseCase?>)
        case p_router_get
		case p_router_set(Parameter<NodeSelectWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didSelectNode__node(let lhsNode), .m_didSelectNode__node(let rhsNode)):
                guard Parameter.compare(lhs: lhsNode, rhs: rhsNode, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<NodeSelectView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<NodeSelectUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<NodeSelectWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didSelectNode__node(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: NodeSelectView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: NodeSelectUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: NodeSelectWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didSelectNode(_ node: Parameter<NemNode>) -> Verify { return Verify(method: .m_didSelectNode__node(`node`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `node` label")
		static func didSelectNode(node: Parameter<NemNode>) -> Verify { return Verify(method: .m_didSelectNode__node(`node`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<NodeSelectView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<NodeSelectUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<NodeSelectWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didSelectNode(_ node: Parameter<NemNode>, perform: @escaping (NemNode) -> Void) -> Perform {
            return Perform(method: .m_didSelectNode__node(`node`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `node` label")
		static func didSelectNode(node: Parameter<NemNode>, perform: @escaping (NemNode) -> Void) -> Perform {
            return Perform(method: .m_didSelectNode__node(`node`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NodeSelectUseCase
class NodeSelectUseCaseMock: NodeSelectUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: NodeSelectInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "NodeSelectUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (NodeSelectInteractorOutput)?





    func fetchNodes() {
        addInvocation(.m_fetchNodes)
		let perform = methodPerformValue(.m_fetchNodes) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_fetchNodes
        case p_output_get
		case p_output_set(Parameter<NodeSelectInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchNodes, .m_fetchNodes):
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<NodeSelectInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_fetchNodes: return 0
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: NodeSelectInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchNodes() -> Verify { return Verify(method: .m_fetchNodes)}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<NodeSelectInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchNodes(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_fetchNodes, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NodeSelectView
class NodeSelectViewMock: NodeSelectView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: NodeSelectPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "NodeSelectViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (NodeSelectPresentation)?





    func showLoading() {
        addInvocation(.m_showLoading)
		let perform = methodPerformValue(.m_showLoading) as? () -> Void
		perform?()
    }

    func hideLoading() {
        addInvocation(.m_hideLoading)
		let perform = methodPerformValue(.m_hideLoading) as? () -> Void
		perform?()
    }

    func showActiveNode(_ activeNodeUrl: String) {
        addInvocation(.m_showActiveNode__activeNodeUrl(Parameter<String>.value(`activeNodeUrl`)))
		let perform = methodPerformValue(.m_showActiveNode__activeNodeUrl(Parameter<String>.value(`activeNodeUrl`))) as? (String) -> Void
		perform?(`activeNodeUrl`)
    }

    func showNodes(_ nodes: [NemNode]) {
        addInvocation(.m_showNodes__nodes(Parameter<[NemNode]>.value(`nodes`)))
		let perform = methodPerformValue(.m_showNodes__nodes(Parameter<[NemNode]>.value(`nodes`))) as? ([NemNode]) -> Void
		perform?(`nodes`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showLoading
        case m_hideLoading
        case m_showActiveNode__activeNodeUrl(Parameter<String>)
        case m_showNodes__nodes(Parameter<[NemNode]>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<NodeSelectPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showLoading, .m_showLoading):
                return true 
            case (.m_hideLoading, .m_hideLoading):
                return true 
            case (.m_showActiveNode__activeNodeUrl(let lhsActivenodeurl), .m_showActiveNode__activeNodeUrl(let rhsActivenodeurl)):
                guard Parameter.compare(lhs: lhsActivenodeurl, rhs: rhsActivenodeurl, with: matcher) else { return false } 
                return true 
            case (.m_showNodes__nodes(let lhsNodes), .m_showNodes__nodes(let rhsNodes)):
                guard Parameter.compare(lhs: lhsNodes, rhs: rhsNodes, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<NodeSelectPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showLoading: return 0
            case .m_hideLoading: return 0
            case let .m_showActiveNode__activeNodeUrl(p0): return p0.intValue
            case let .m_showNodes__nodes(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: NodeSelectPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showLoading() -> Verify { return Verify(method: .m_showLoading)}
        static func hideLoading() -> Verify { return Verify(method: .m_hideLoading)}
        static func showActiveNode(_ activeNodeUrl: Parameter<String>) -> Verify { return Verify(method: .m_showActiveNode__activeNodeUrl(`activeNodeUrl`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `activeNodeUrl` label")
		static func showActiveNode(activeNodeUrl: Parameter<String>) -> Verify { return Verify(method: .m_showActiveNode__activeNodeUrl(`activeNodeUrl`))}
        static func showNodes(_ nodes: Parameter<[NemNode]>) -> Verify { return Verify(method: .m_showNodes__nodes(`nodes`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `nodes` label")
		static func showNodes(nodes: Parameter<[NemNode]>) -> Verify { return Verify(method: .m_showNodes__nodes(`nodes`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<NodeSelectPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoading, performs: perform)
        }
        static func hideLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideLoading, performs: perform)
        }
        static func showActiveNode(_ activeNodeUrl: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showActiveNode__activeNodeUrl(`activeNodeUrl`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `activeNodeUrl` label")
		static func showActiveNode(activeNodeUrl: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showActiveNode__activeNodeUrl(`activeNodeUrl`), performs: perform)
        }
        static func showNodes(_ nodes: Parameter<[NemNode]>, perform: @escaping ([NemNode]) -> Void) -> Perform {
            return Perform(method: .m_showNodes__nodes(`nodes`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `nodes` label")
		static func showNodes(nodes: Parameter<[NemNode]>, perform: @escaping ([NemNode]) -> Void) -> Perform {
            return Perform(method: .m_showNodes__nodes(`nodes`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - NodeSelectWireframe
class NodeSelectWireframeMock: NodeSelectWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "NodeSelectWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - PinDialogInteractorOutput
class PinDialogInteractorOutputMock: PinDialogInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func pinValidated(_ result: Bool, _ pin: String) {
        addInvocation(.m_pinValidated__result_pin(Parameter<Bool>.value(`result`), Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_pinValidated__result_pin(Parameter<Bool>.value(`result`), Parameter<String>.value(`pin`))) as? (Bool, String) -> Void
		perform?(`result`, `pin`)
    }

    func pinRegistered(_ result: Bool, _ pin: String) {
        addInvocation(.m_pinRegistered__result_pin(Parameter<Bool>.value(`result`), Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_pinRegistered__result_pin(Parameter<Bool>.value(`result`), Parameter<String>.value(`pin`))) as? (Bool, String) -> Void
		perform?(`result`, `pin`)
    }


    fileprivate enum MethodType {
        case m_pinValidated__result_pin(Parameter<Bool>, Parameter<String>)
        case m_pinRegistered__result_pin(Parameter<Bool>, Parameter<String>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_pinValidated__result_pin(let lhsResult, let lhsPin), .m_pinValidated__result_pin(let rhsResult, let rhsPin)):
                guard Parameter.compare(lhs: lhsResult, rhs: rhsResult, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_pinRegistered__result_pin(let lhsResult, let lhsPin), .m_pinRegistered__result_pin(let rhsResult, let rhsPin)):
                guard Parameter.compare(lhs: lhsResult, rhs: rhsResult, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_pinValidated__result_pin(p0, p1): return p0.intValue + p1.intValue
            case let .m_pinRegistered__result_pin(p0, p1): return p0.intValue + p1.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func pinValidated(_ result: Parameter<Bool>, _ pin: Parameter<String>) -> Verify { return Verify(method: .m_pinValidated__result_pin(`result`, `pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label, remove `pin` label")
		static func pinValidated(result: Parameter<Bool>, pin: Parameter<String>) -> Verify { return Verify(method: .m_pinValidated__result_pin(`result`, `pin`))}
        static func pinRegistered(_ result: Parameter<Bool>, _ pin: Parameter<String>) -> Verify { return Verify(method: .m_pinRegistered__result_pin(`result`, `pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label, remove `pin` label")
		static func pinRegistered(result: Parameter<Bool>, pin: Parameter<String>) -> Verify { return Verify(method: .m_pinRegistered__result_pin(`result`, `pin`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func pinValidated(_ result: Parameter<Bool>, _ pin: Parameter<String>, perform: @escaping (Bool, String) -> Void) -> Perform {
            return Perform(method: .m_pinValidated__result_pin(`result`, `pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label, remove `pin` label")
		static func pinValidated(result: Parameter<Bool>, pin: Parameter<String>, perform: @escaping (Bool, String) -> Void) -> Perform {
            return Perform(method: .m_pinValidated__result_pin(`result`, `pin`), performs: perform)
        }
        static func pinRegistered(_ result: Parameter<Bool>, _ pin: Parameter<String>, perform: @escaping (Bool, String) -> Void) -> Perform {
            return Perform(method: .m_pinRegistered__result_pin(`result`, `pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label, remove `pin` label")
		static func pinRegistered(result: Parameter<Bool>, pin: Parameter<String>, perform: @escaping (Bool, String) -> Void) -> Perform {
            return Perform(method: .m_pinRegistered__result_pin(`result`, `pin`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - PinDialogPresentation
class PinDialogPresentationMock: PinDialogPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: PinDialogView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "PinDialogPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (PinDialogView)?

    var interactor: PinDialogUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "PinDialogPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (PinDialogUseCase)?

    var router: PinDialogWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "PinDialogPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (PinDialogWireframe)?





    func didClickNumber(_ number: Int) {
        addInvocation(.m_didClickNumber__number(Parameter<Int>.value(`number`)))
		let perform = methodPerformValue(.m_didClickNumber__number(Parameter<Int>.value(`number`))) as? (Int) -> Void
		perform?(`number`)
    }

    func didClickDelete() {
        addInvocation(.m_didClickDelete)
		let perform = methodPerformValue(.m_didClickDelete) as? () -> Void
		perform?()
    }

    func didClickCancel() {
        addInvocation(.m_didClickCancel)
		let perform = methodPerformValue(.m_didClickCancel) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickNumber__number(Parameter<Int>)
        case m_didClickDelete
        case m_didClickCancel
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<PinDialogView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<PinDialogUseCase?>)
        case p_router_get
		case p_router_set(Parameter<PinDialogWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickNumber__number(let lhsNumber), .m_didClickNumber__number(let rhsNumber)):
                guard Parameter.compare(lhs: lhsNumber, rhs: rhsNumber, with: matcher) else { return false } 
                return true 
            case (.m_didClickDelete, .m_didClickDelete):
                return true 
            case (.m_didClickCancel, .m_didClickCancel):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<PinDialogView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<PinDialogUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<PinDialogWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didClickNumber__number(p0): return p0.intValue
            case .m_didClickDelete: return 0
            case .m_didClickCancel: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: PinDialogView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: PinDialogUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: PinDialogWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickNumber(_ number: Parameter<Int>) -> Verify { return Verify(method: .m_didClickNumber__number(`number`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `number` label")
		static func didClickNumber(number: Parameter<Int>) -> Verify { return Verify(method: .m_didClickNumber__number(`number`))}
        static func didClickDelete() -> Verify { return Verify(method: .m_didClickDelete)}
        static func didClickCancel() -> Verify { return Verify(method: .m_didClickCancel)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<PinDialogView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<PinDialogUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<PinDialogWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickNumber(_ number: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didClickNumber__number(`number`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `number` label")
		static func didClickNumber(number: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didClickNumber__number(`number`), performs: perform)
        }
        static func didClickDelete(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickDelete, performs: perform)
        }
        static func didClickCancel(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickCancel, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - PinDialogUseCase
class PinDialogUseCaseMock: PinDialogUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: PinDialogInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "PinDialogUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (PinDialogInteractorOutput)?





    func validateCode(_ pin: String) {
        addInvocation(.m_validateCode__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_validateCode__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func registerCode(_ oldCode: String, _ newCode: String) {
        addInvocation(.m_registerCode__oldCode_newCode(Parameter<String>.value(`oldCode`), Parameter<String>.value(`newCode`)))
		let perform = methodPerformValue(.m_registerCode__oldCode_newCode(Parameter<String>.value(`oldCode`), Parameter<String>.value(`newCode`))) as? (String, String) -> Void
		perform?(`oldCode`, `newCode`)
    }


    fileprivate enum MethodType {
        case m_validateCode__pin(Parameter<String>)
        case m_registerCode__oldCode_newCode(Parameter<String>, Parameter<String>)
        case p_output_get
		case p_output_set(Parameter<PinDialogInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_validateCode__pin(let lhsPin), .m_validateCode__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_registerCode__oldCode_newCode(let lhsOldcode, let lhsNewcode), .m_registerCode__oldCode_newCode(let rhsOldcode, let rhsNewcode)):
                guard Parameter.compare(lhs: lhsOldcode, rhs: rhsOldcode, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsNewcode, rhs: rhsNewcode, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<PinDialogInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_validateCode__pin(p0): return p0.intValue
            case let .m_registerCode__oldCode_newCode(p0, p1): return p0.intValue + p1.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: PinDialogInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func validateCode(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_validateCode__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func validateCode(pin: Parameter<String>) -> Verify { return Verify(method: .m_validateCode__pin(`pin`))}
        static func registerCode(_ oldCode: Parameter<String>, _ newCode: Parameter<String>) -> Verify { return Verify(method: .m_registerCode__oldCode_newCode(`oldCode`, `newCode`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `oldCode` label, remove `newCode` label")
		static func registerCode(oldCode: Parameter<String>, newCode: Parameter<String>) -> Verify { return Verify(method: .m_registerCode__oldCode_newCode(`oldCode`, `newCode`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<PinDialogInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func validateCode(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_validateCode__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func validateCode(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_validateCode__pin(`pin`), performs: perform)
        }
        static func registerCode(_ oldCode: Parameter<String>, _ newCode: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_registerCode__oldCode_newCode(`oldCode`, `newCode`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `oldCode` label, remove `newCode` label")
		static func registerCode(oldCode: Parameter<String>, newCode: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_registerCode__oldCode_newCode(`oldCode`, `newCode`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - PinDialogView
class PinDialogViewMock: PinDialogView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: PinDialogPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "PinDialogViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (PinDialogPresentation)?





    func showMessage(_ message: String) {
        addInvocation(.m_showMessage__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showMessage__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showInputted(_ count: Int) {
        addInvocation(.m_showInputted__count(Parameter<Int>.value(`count`)))
		let perform = methodPerformValue(.m_showInputted__count(Parameter<Int>.value(`count`))) as? (Int) -> Void
		perform?(`count`)
    }

    func showResult(_ result: Bool) {
        addInvocation(.m_showResult__result(Parameter<Bool>.value(`result`)))
		let perform = methodPerformValue(.m_showResult__result(Parameter<Bool>.value(`result`))) as? (Bool) -> Void
		perform?(`result`)
    }

    func showRegistrationMessage() {
        addInvocation(.m_showRegistrationMessage)
		let perform = methodPerformValue(.m_showRegistrationMessage) as? () -> Void
		perform?()
    }

    func hideCancel() {
        addInvocation(.m_hideCancel)
		let perform = methodPerformValue(.m_hideCancel) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showMessage__message(Parameter<String>)
        case m_showInputted__count(Parameter<Int>)
        case m_showResult__result(Parameter<Bool>)
        case m_showRegistrationMessage
        case m_hideCancel
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<PinDialogPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showMessage__message(let lhsMessage), .m_showMessage__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showInputted__count(let lhsCount), .m_showInputted__count(let rhsCount)):
                guard Parameter.compare(lhs: lhsCount, rhs: rhsCount, with: matcher) else { return false } 
                return true 
            case (.m_showResult__result(let lhsResult), .m_showResult__result(let rhsResult)):
                guard Parameter.compare(lhs: lhsResult, rhs: rhsResult, with: matcher) else { return false } 
                return true 
            case (.m_showRegistrationMessage, .m_showRegistrationMessage):
                return true 
            case (.m_hideCancel, .m_hideCancel):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<PinDialogPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showMessage__message(p0): return p0.intValue
            case let .m_showInputted__count(p0): return p0.intValue
            case let .m_showResult__result(p0): return p0.intValue
            case .m_showRegistrationMessage: return 0
            case .m_hideCancel: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: PinDialogPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showMessage(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        static func showInputted(_ count: Parameter<Int>) -> Verify { return Verify(method: .m_showInputted__count(`count`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `count` label")
		static func showInputted(count: Parameter<Int>) -> Verify { return Verify(method: .m_showInputted__count(`count`))}
        static func showResult(_ result: Parameter<Bool>) -> Verify { return Verify(method: .m_showResult__result(`result`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label")
		static func showResult(result: Parameter<Bool>) -> Verify { return Verify(method: .m_showResult__result(`result`))}
        static func showRegistrationMessage() -> Verify { return Verify(method: .m_showRegistrationMessage)}
        static func hideCancel() -> Verify { return Verify(method: .m_hideCancel)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<PinDialogPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showMessage(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        static func showInputted(_ count: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_showInputted__count(`count`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `count` label")
		static func showInputted(count: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_showInputted__count(`count`), performs: perform)
        }
        static func showResult(_ result: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showResult__result(`result`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label")
		static func showResult(result: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showResult__result(`result`), performs: perform)
        }
        static func showRegistrationMessage(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showRegistrationMessage, performs: perform)
        }
        static func hideCancel(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideCancel, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - PinDialogWireframe
class PinDialogWireframeMock: PinDialogWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "PinDialogWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(        forRegistration: Bool,        cancelable: Bool,        message: String?,        handler: ((String?) -> Void)?) -> UIViewController {
        addInvocation(.sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<String?>.value(`message`), Parameter<((String?) -> Void)?>.value(`handler`)))
		let perform = methodPerformValue(.sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<String?>.value(`message`), Parameter<((String?) -> Void)?>.value(`handler`))) as? (Bool, Bool, String?, ((String?) -> Void)?) -> Void
		perform?(`forRegistration`, `cancelable`, `message`, `handler`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<String?>.value(`message`), Parameter<((String?) -> Void)?>.value(`handler`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(        forRegistration: Bool,        cancelable: Bool,        message: String?,        handler: ((String?) -> Void)?). Use given")
		}
		return __value
    }

    func dismiss(pin: String?, _ handler: ((String?) -> Void)?) {
        addInvocation(.m_dismiss__pin_pin_handler(Parameter<String?>.value(`pin`), Parameter<((String?) -> Void)?>.value(`handler`)))
		let perform = methodPerformValue(.m_dismiss__pin_pin_handler(Parameter<String?>.value(`pin`), Parameter<((String?) -> Void)?>.value(`handler`))) as? (String?, ((String?) -> Void)?) -> Void
		perform?(`pin`, `handler`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(Parameter<Bool>, Parameter<Bool>, Parameter<String?>, Parameter<((String?) -> Void)?>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(let lhsForregistration, let lhsCancelable, let lhsMessage, let lhsHandler), .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(let rhsForregistration, let rhsCancelable, let rhsMessage, let rhsHandler)):
                guard Parameter.compare(lhs: lhsForregistration, rhs: rhsForregistration, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCancelable, rhs: rhsCancelable, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsHandler, rhs: rhsHandler, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(p0, p1, p2, p3): return p0.intValue + p1.intValue + p2.intValue + p3.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(`forRegistration`, `cancelable`, `message`, `handler`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(`forRegistration`, `cancelable`, `message`, `handler`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(`forRegistration`, `cancelable`, `message`, `handler`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>, perform: @escaping (Bool, Bool, String?, ((String?) -> Void)?) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__forRegistration_forRegistrationcancelable_cancelablemessage_messagehandler_handler(`forRegistration`, `cancelable`, `message`, `handler`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_dismiss__pin_pin_handler(Parameter<String?>, Parameter<((String?) -> Void)?>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_dismiss__pin_pin_handler(let lhsPin, let lhsHandler), .m_dismiss__pin_pin_handler(let rhsPin, let rhsHandler)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsHandler, rhs: rhsHandler, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_dismiss__pin_pin_handler(p0, p1): return p0.intValue + p1.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func dismiss(pin: Parameter<String?>, _ handler: Parameter<((String?) -> Void)?>) -> Verify { return Verify(method: .m_dismiss__pin_pin_handler(`pin`, `handler`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `handler` label")
		static func dismiss(pin: Parameter<String?>, handler: Parameter<((String?) -> Void)?>) -> Verify { return Verify(method: .m_dismiss__pin_pin_handler(`pin`, `handler`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func dismiss(pin: Parameter<String?>, _ handler: Parameter<((String?) -> Void)?>, perform: @escaping (String?, ((String?) -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__pin_pin_handler(`pin`, `handler`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `handler` label")
		static func dismiss(pin: Parameter<String?>, handler: Parameter<((String?) -> Void)?>, perform: @escaping (String?, ((String?) -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__pin_pin_handler(`pin`, `handler`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - ScanTabInteractorOutput
class ScanTabInteractorOutputMock: ScanTabInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func publicKeyFetched(_ publicKey: String?) {
        addInvocation(.m_publicKeyFetched__publicKey(Parameter<String?>.value(`publicKey`)))
		let perform = methodPerformValue(.m_publicKeyFetched__publicKey(Parameter<String?>.value(`publicKey`))) as? (String?) -> Void
		perform?(`publicKey`)
    }

    func publicKeyFetchFailed(_ error: Error) {
        addInvocation(.m_publicKeyFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_publicKeyFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_publicKeyFetched__publicKey(Parameter<String?>)
        case m_publicKeyFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_publicKeyFetched__publicKey(let lhsPublickey), .m_publicKeyFetched__publicKey(let rhsPublickey)):
                guard Parameter.compare(lhs: lhsPublickey, rhs: rhsPublickey, with: matcher) else { return false } 
                return true 
            case (.m_publicKeyFetchFailed__error(let lhsError), .m_publicKeyFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_publicKeyFetched__publicKey(p0): return p0.intValue
            case let .m_publicKeyFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func publicKeyFetched(_ publicKey: Parameter<String?>) -> Verify { return Verify(method: .m_publicKeyFetched__publicKey(`publicKey`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `publicKey` label")
		static func publicKeyFetched(publicKey: Parameter<String?>) -> Verify { return Verify(method: .m_publicKeyFetched__publicKey(`publicKey`))}
        static func publicKeyFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_publicKeyFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func publicKeyFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_publicKeyFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func publicKeyFetched(_ publicKey: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetched__publicKey(`publicKey`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `publicKey` label")
		static func publicKeyFetched(publicKey: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetched__publicKey(`publicKey`), performs: perform)
        }
        static func publicKeyFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func publicKeyFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ScanTabPresentation
class ScanTabPresentationMock: ScanTabPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: ScanTabView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "ScanTabPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (ScanTabView)?

    var interactor: ScanTabUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "ScanTabPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (ScanTabUseCase)?

    var router: ScanTabWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "ScanTabPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (ScanTabWireframe)?





    func didScanAddress(_ address: String) {
        addInvocation(.m_didScanAddress__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_didScanAddress__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }

    func didScanInvoice(_ invoice: InvoiceQr) {
        addInvocation(.m_didScanInvoice__invoice(Parameter<InvoiceQr>.value(`invoice`)))
		let perform = methodPerformValue(.m_didScanInvoice__invoice(Parameter<InvoiceQr>.value(`invoice`))) as? (InvoiceQr) -> Void
		perform?(`invoice`)
    }

    func didCatchError(_ message: String) {
        addInvocation(.m_didCatchError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_didCatchError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func didClickGoPinSetting() {
        addInvocation(.m_didClickGoPinSetting)
		let perform = methodPerformValue(.m_didClickGoPinSetting) as? () -> Void
		perform?()
    }

    func didClickGoWalletSelect() {
        addInvocation(.m_didClickGoWalletSelect)
		let perform = methodPerformValue(.m_didClickGoWalletSelect) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didScanAddress__address(Parameter<String>)
        case m_didScanInvoice__invoice(Parameter<InvoiceQr>)
        case m_didCatchError__message(Parameter<String>)
        case m_didClickGoPinSetting
        case m_didClickGoWalletSelect
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<ScanTabView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<ScanTabUseCase?>)
        case p_router_get
		case p_router_set(Parameter<ScanTabWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didScanAddress__address(let lhsAddress), .m_didScanAddress__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.m_didScanInvoice__invoice(let lhsInvoice), .m_didScanInvoice__invoice(let rhsInvoice)):
                guard Parameter.compare(lhs: lhsInvoice, rhs: rhsInvoice, with: matcher) else { return false } 
                return true 
            case (.m_didCatchError__message(let lhsMessage), .m_didCatchError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_didClickGoPinSetting, .m_didClickGoPinSetting):
                return true 
            case (.m_didClickGoWalletSelect, .m_didClickGoWalletSelect):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<ScanTabView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<ScanTabUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<ScanTabWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didScanAddress__address(p0): return p0.intValue
            case let .m_didScanInvoice__invoice(p0): return p0.intValue
            case let .m_didCatchError__message(p0): return p0.intValue
            case .m_didClickGoPinSetting: return 0
            case .m_didClickGoWalletSelect: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: ScanTabView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: ScanTabUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: ScanTabWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didScanAddress(_ address: Parameter<String>) -> Verify { return Verify(method: .m_didScanAddress__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func didScanAddress(address: Parameter<String>) -> Verify { return Verify(method: .m_didScanAddress__address(`address`))}
        static func didScanInvoice(_ invoice: Parameter<InvoiceQr>) -> Verify { return Verify(method: .m_didScanInvoice__invoice(`invoice`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `invoice` label")
		static func didScanInvoice(invoice: Parameter<InvoiceQr>) -> Verify { return Verify(method: .m_didScanInvoice__invoice(`invoice`))}
        static func didCatchError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_didCatchError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didCatchError(message: Parameter<String>) -> Verify { return Verify(method: .m_didCatchError__message(`message`))}
        static func didClickGoPinSetting() -> Verify { return Verify(method: .m_didClickGoPinSetting)}
        static func didClickGoWalletSelect() -> Verify { return Verify(method: .m_didClickGoWalletSelect)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<ScanTabView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<ScanTabUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<ScanTabWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didScanAddress(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didScanAddress__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func didScanAddress(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didScanAddress__address(`address`), performs: perform)
        }
        static func didScanInvoice(_ invoice: Parameter<InvoiceQr>, perform: @escaping (InvoiceQr) -> Void) -> Perform {
            return Perform(method: .m_didScanInvoice__invoice(`invoice`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `invoice` label")
		static func didScanInvoice(invoice: Parameter<InvoiceQr>, perform: @escaping (InvoiceQr) -> Void) -> Perform {
            return Perform(method: .m_didScanInvoice__invoice(`invoice`), performs: perform)
        }
        static func didCatchError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didCatchError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didCatchError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didCatchError__message(`message`), performs: perform)
        }
        static func didClickGoPinSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGoPinSetting, performs: perform)
        }
        static func didClickGoWalletSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGoWalletSelect, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ScanTabUseCase
class ScanTabUseCaseMock: ScanTabUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: ScanTabInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "ScanTabUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (ScanTabInteractorOutput)?





    func fetchPublicKey(_ address: String) {
        addInvocation(.m_fetchPublicKey__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_fetchPublicKey__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }


    fileprivate enum MethodType {
        case m_fetchPublicKey__address(Parameter<String>)
        case p_output_get
		case p_output_set(Parameter<ScanTabInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchPublicKey__address(let lhsAddress), .m_fetchPublicKey__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<ScanTabInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchPublicKey__address(p0): return p0.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: ScanTabInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchPublicKey(_ address: Parameter<String>) -> Verify { return Verify(method: .m_fetchPublicKey__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchPublicKey(address: Parameter<String>) -> Verify { return Verify(method: .m_fetchPublicKey__address(`address`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<ScanTabInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchPublicKey(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchPublicKey__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchPublicKey(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchPublicKey__address(`address`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ScanTabView
class ScanTabViewMock: ScanTabView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: ScanTabPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "ScanTabViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (ScanTabPresentation)?





    func startScan() {
        addInvocation(.m_startScan)
		let perform = methodPerformValue(.m_startScan) as? () -> Void
		perform?()
    }

    func stopScan() {
        addInvocation(.m_stopScan)
		let perform = methodPerformValue(.m_stopScan) as? () -> Void
		perform?()
    }

    func showLoading() {
        addInvocation(.m_showLoading)
		let perform = methodPerformValue(.m_showLoading) as? () -> Void
		perform?()
    }

    func hideLoading() {
        addInvocation(.m_hideLoading)
		let perform = methodPerformValue(.m_hideLoading) as? () -> Void
		perform?()
    }

    func pause(_ isPaused: Bool) {
        addInvocation(.m_pause__isPaused(Parameter<Bool>.value(`isPaused`)))
		let perform = methodPerformValue(.m_pause__isPaused(Parameter<Bool>.value(`isPaused`))) as? (Bool) -> Void
		perform?(`isPaused`)
    }

    func showNotSetPinError() {
        addInvocation(.m_showNotSetPinError)
		let perform = methodPerformValue(.m_showNotSetPinError) as? () -> Void
		perform?()
    }

    func showNotSelectWalletError() {
        addInvocation(.m_showNotSelectWalletError)
		let perform = methodPerformValue(.m_showNotSelectWalletError) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_startScan
        case m_stopScan
        case m_showLoading
        case m_hideLoading
        case m_pause__isPaused(Parameter<Bool>)
        case m_showNotSetPinError
        case m_showNotSelectWalletError
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<ScanTabPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_startScan, .m_startScan):
                return true 
            case (.m_stopScan, .m_stopScan):
                return true 
            case (.m_showLoading, .m_showLoading):
                return true 
            case (.m_hideLoading, .m_hideLoading):
                return true 
            case (.m_pause__isPaused(let lhsIspaused), .m_pause__isPaused(let rhsIspaused)):
                guard Parameter.compare(lhs: lhsIspaused, rhs: rhsIspaused, with: matcher) else { return false } 
                return true 
            case (.m_showNotSetPinError, .m_showNotSetPinError):
                return true 
            case (.m_showNotSelectWalletError, .m_showNotSelectWalletError):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<ScanTabPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_startScan: return 0
            case .m_stopScan: return 0
            case .m_showLoading: return 0
            case .m_hideLoading: return 0
            case let .m_pause__isPaused(p0): return p0.intValue
            case .m_showNotSetPinError: return 0
            case .m_showNotSelectWalletError: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: ScanTabPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func startScan() -> Verify { return Verify(method: .m_startScan)}
        static func stopScan() -> Verify { return Verify(method: .m_stopScan)}
        static func showLoading() -> Verify { return Verify(method: .m_showLoading)}
        static func hideLoading() -> Verify { return Verify(method: .m_hideLoading)}
        static func pause(_ isPaused: Parameter<Bool>) -> Verify { return Verify(method: .m_pause__isPaused(`isPaused`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPaused` label")
		static func pause(isPaused: Parameter<Bool>) -> Verify { return Verify(method: .m_pause__isPaused(`isPaused`))}
        static func showNotSetPinError() -> Verify { return Verify(method: .m_showNotSetPinError)}
        static func showNotSelectWalletError() -> Verify { return Verify(method: .m_showNotSelectWalletError)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<ScanTabPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func startScan(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_startScan, performs: perform)
        }
        static func stopScan(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_stopScan, performs: perform)
        }
        static func showLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoading, performs: perform)
        }
        static func hideLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideLoading, performs: perform)
        }
        static func pause(_ isPaused: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pause__isPaused(`isPaused`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPaused` label")
		static func pause(isPaused: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_pause__isPaused(`isPaused`), performs: perform)
        }
        static func showNotSetPinError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showNotSetPinError, performs: perform)
        }
        static func showNotSelectWalletError(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showNotSelectWalletError, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - ScanTabWireframe
class ScanTabWireframeMock: ScanTabWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "ScanTabWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentSendAmount(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendAmount__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendAmount__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    func presentSendMode(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendMode__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendMode__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    func presentSendConfirmation(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    func presentSetting() {
        addInvocation(.m_presentSetting)
		let perform = methodPerformValue(.m_presentSetting) as? () -> Void
		perform?()
    }

    func presentWalletSelect() {
        addInvocation(.m_presentWalletSelect)
		let perform = methodPerformValue(.m_presentWalletSelect) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendAmount__sendTransaction(Parameter<SendTransaction>)
        case m_presentSendMode__sendTransaction(Parameter<SendTransaction>)
        case m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>)
        case m_presentSetting
        case m_presentWalletSelect
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendAmount__sendTransaction(let lhsSendtransaction), .m_presentSendAmount__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.m_presentSendMode__sendTransaction(let lhsSendtransaction), .m_presentSendMode__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.m_presentSendConfirmation__sendTransaction(let lhsSendtransaction), .m_presentSendConfirmation__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.m_presentSetting, .m_presentSetting):
                return true 
            case (.m_presentWalletSelect, .m_presentWalletSelect):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentSendAmount__sendTransaction(p0): return p0.intValue
            case let .m_presentSendMode__sendTransaction(p0): return p0.intValue
            case let .m_presentSendConfirmation__sendTransaction(p0): return p0.intValue
            case .m_presentSetting: return 0
            case .m_presentWalletSelect: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendAmount(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendAmount__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendAmount(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendAmount__sendTransaction(`sendTransaction`))}
        static func presentSendMode(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMode__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMode(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMode__sendTransaction(`sendTransaction`))}
        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        static func presentSetting() -> Verify { return Verify(method: .m_presentSetting)}
        static func presentWalletSelect() -> Verify { return Verify(method: .m_presentWalletSelect)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendAmount(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendAmount__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendAmount(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendAmount__sendTransaction(`sendTransaction`), performs: perform)
        }
        static func presentSendMode(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMode__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMode(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMode__sendTransaction(`sendTransaction`), performs: perform)
        }
        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
        static func presentSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSetting, performs: perform)
        }
        static func presentWalletSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentWalletSelect, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendAmountInteractorOutput
class SendAmountInteractorOutputMock: SendAmountInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func mosaicOwnedFetched(_ mosaics: [MosaicDetail]) {
        addInvocation(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>.value(`mosaics`))) as? ([MosaicDetail]) -> Void
		perform?(`mosaics`)
    }

    func mosaicOwnedFetchFailed(_ error: Error) {
        addInvocation(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_mosaicOwnedFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    func rateFetched(_ rate: Decimal) {
        addInvocation(.m_rateFetched__rate(Parameter<Decimal>.value(`rate`)))
		let perform = methodPerformValue(.m_rateFetched__rate(Parameter<Decimal>.value(`rate`))) as? (Decimal) -> Void
		perform?(`rate`)
    }

    func rateFetchFailed(_ error: Error) {
        addInvocation(.m_rateFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_rateFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_mosaicOwnedFetched__mosaics(Parameter<[MosaicDetail]>)
        case m_mosaicOwnedFetchFailed__error(Parameter<Error>)
        case m_rateFetched__rate(Parameter<Decimal>)
        case m_rateFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_mosaicOwnedFetched__mosaics(let lhsMosaics), .m_mosaicOwnedFetched__mosaics(let rhsMosaics)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                return true 
            case (.m_mosaicOwnedFetchFailed__error(let lhsError), .m_mosaicOwnedFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_rateFetched__rate(let lhsRate), .m_rateFetched__rate(let rhsRate)):
                guard Parameter.compare(lhs: lhsRate, rhs: rhsRate, with: matcher) else { return false } 
                return true 
            case (.m_rateFetchFailed__error(let lhsError), .m_rateFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_mosaicOwnedFetched__mosaics(p0): return p0.intValue
            case let .m_mosaicOwnedFetchFailed__error(p0): return p0.intValue
            case let .m_rateFetched__rate(p0): return p0.intValue
            case let .m_rateFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_mosaicOwnedFetched__mosaics(`mosaics`))}
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicOwnedFetchFailed__error(`error`))}
        static func rateFetched(_ rate: Parameter<Decimal>) -> Verify { return Verify(method: .m_rateFetched__rate(`rate`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `rate` label")
		static func rateFetched(rate: Parameter<Decimal>) -> Verify { return Verify(method: .m_rateFetched__rate(`rate`))}
        static func rateFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_rateFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func rateFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_rateFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func mosaicOwnedFetched(_ mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func mosaicOwnedFetched(mosaics: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetched__mosaics(`mosaics`), performs: perform)
        }
        static func mosaicOwnedFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicOwnedFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicOwnedFetchFailed__error(`error`), performs: perform)
        }
        static func rateFetched(_ rate: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_rateFetched__rate(`rate`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `rate` label")
		static func rateFetched(rate: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_rateFetched__rate(`rate`), performs: perform)
        }
        static func rateFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_rateFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func rateFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_rateFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendAmountPresentation
class SendAmountPresentationMock: SendAmountPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendAmountView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendAmountPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendAmountView)?

    var interactor: SendAmountUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendAmountPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendAmountUseCase)?

    var router: SendAmountWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendAmountPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendAmountWireframe)?





    func didClickMosaicTab() {
        addInvocation(.m_didClickMosaicTab)
		let perform = methodPerformValue(.m_didClickMosaicTab) as? () -> Void
		perform?()
    }

    func didClickAmountTab() {
        addInvocation(.m_didClickAmountTab)
		let perform = methodPerformValue(.m_didClickAmountTab) as? () -> Void
		perform?()
    }

    func didChangeAmountPage(_ pageIndex: Int) {
        addInvocation(.m_didChangeAmountPage__pageIndex(Parameter<Int>.value(`pageIndex`)))
		let perform = methodPerformValue(.m_didChangeAmountPage__pageIndex(Parameter<Int>.value(`pageIndex`))) as? (Int) -> Void
		perform?(`pageIndex`)
    }

    func didChangeFormula(_ formula: String) {
        addInvocation(.m_didChangeFormula__formula(Parameter<String>.value(`formula`)))
		let perform = methodPerformValue(.m_didChangeFormula__formula(Parameter<String>.value(`formula`))) as? (String) -> Void
		perform?(`formula`)
    }

    func didCalculateFormula(_ value: Decimal) {
        addInvocation(.m_didCalculateFormula__value(Parameter<Decimal>.value(`value`)))
		let perform = methodPerformValue(.m_didCalculateFormula__value(Parameter<Decimal>.value(`value`))) as? (Decimal) -> Void
		perform?(`value`)
    }

    func didConfirm() {
        addInvocation(.m_didConfirm)
		let perform = methodPerformValue(.m_didConfirm) as? () -> Void
		perform?()
    }

    func didChangeMosaicWithXem(_ withXem: Bool) {
        addInvocation(.m_didChangeMosaicWithXem__withXem(Parameter<Bool>.value(`withXem`)))
		let perform = methodPerformValue(.m_didChangeMosaicWithXem__withXem(Parameter<Bool>.value(`withXem`))) as? (Bool) -> Void
		perform?(`withXem`)
    }

    func didSelectMosaicOwned(_ mosaic: MosaicDetail) {
        addInvocation(.m_didSelectMosaicOwned__mosaic(Parameter<MosaicDetail>.value(`mosaic`)))
		let perform = methodPerformValue(.m_didSelectMosaicOwned__mosaic(Parameter<MosaicDetail>.value(`mosaic`))) as? (MosaicDetail) -> Void
		perform?(`mosaic`)
    }

    func didDeselectMosaicOwned(_ mosaic: MosaicDetail) {
        addInvocation(.m_didDeselectMosaicOwned__mosaic(Parameter<MosaicDetail>.value(`mosaic`)))
		let perform = methodPerformValue(.m_didDeselectMosaicOwned__mosaic(Parameter<MosaicDetail>.value(`mosaic`))) as? (MosaicDetail) -> Void
		perform?(`mosaic`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickMosaicTab
        case m_didClickAmountTab
        case m_didChangeAmountPage__pageIndex(Parameter<Int>)
        case m_didChangeFormula__formula(Parameter<String>)
        case m_didCalculateFormula__value(Parameter<Decimal>)
        case m_didConfirm
        case m_didChangeMosaicWithXem__withXem(Parameter<Bool>)
        case m_didSelectMosaicOwned__mosaic(Parameter<MosaicDetail>)
        case m_didDeselectMosaicOwned__mosaic(Parameter<MosaicDetail>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SendAmountView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendAmountUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendAmountWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickMosaicTab, .m_didClickMosaicTab):
                return true 
            case (.m_didClickAmountTab, .m_didClickAmountTab):
                return true 
            case (.m_didChangeAmountPage__pageIndex(let lhsPageindex), .m_didChangeAmountPage__pageIndex(let rhsPageindex)):
                guard Parameter.compare(lhs: lhsPageindex, rhs: rhsPageindex, with: matcher) else { return false } 
                return true 
            case (.m_didChangeFormula__formula(let lhsFormula), .m_didChangeFormula__formula(let rhsFormula)):
                guard Parameter.compare(lhs: lhsFormula, rhs: rhsFormula, with: matcher) else { return false } 
                return true 
            case (.m_didCalculateFormula__value(let lhsValue), .m_didCalculateFormula__value(let rhsValue)):
                guard Parameter.compare(lhs: lhsValue, rhs: rhsValue, with: matcher) else { return false } 
                return true 
            case (.m_didConfirm, .m_didConfirm):
                return true 
            case (.m_didChangeMosaicWithXem__withXem(let lhsWithxem), .m_didChangeMosaicWithXem__withXem(let rhsWithxem)):
                guard Parameter.compare(lhs: lhsWithxem, rhs: rhsWithxem, with: matcher) else { return false } 
                return true 
            case (.m_didSelectMosaicOwned__mosaic(let lhsMosaic), .m_didSelectMosaicOwned__mosaic(let rhsMosaic)):
                guard Parameter.compare(lhs: lhsMosaic, rhs: rhsMosaic, with: matcher) else { return false } 
                return true 
            case (.m_didDeselectMosaicOwned__mosaic(let lhsMosaic), .m_didDeselectMosaicOwned__mosaic(let rhsMosaic)):
                guard Parameter.compare(lhs: lhsMosaic, rhs: rhsMosaic, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendAmountView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendAmountUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendAmountWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickMosaicTab: return 0
            case .m_didClickAmountTab: return 0
            case let .m_didChangeAmountPage__pageIndex(p0): return p0.intValue
            case let .m_didChangeFormula__formula(p0): return p0.intValue
            case let .m_didCalculateFormula__value(p0): return p0.intValue
            case .m_didConfirm: return 0
            case let .m_didChangeMosaicWithXem__withXem(p0): return p0.intValue
            case let .m_didSelectMosaicOwned__mosaic(p0): return p0.intValue
            case let .m_didDeselectMosaicOwned__mosaic(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendAmountView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendAmountUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendAmountWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickMosaicTab() -> Verify { return Verify(method: .m_didClickMosaicTab)}
        static func didClickAmountTab() -> Verify { return Verify(method: .m_didClickAmountTab)}
        static func didChangeAmountPage(_ pageIndex: Parameter<Int>) -> Verify { return Verify(method: .m_didChangeAmountPage__pageIndex(`pageIndex`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pageIndex` label")
		static func didChangeAmountPage(pageIndex: Parameter<Int>) -> Verify { return Verify(method: .m_didChangeAmountPage__pageIndex(`pageIndex`))}
        static func didChangeFormula(_ formula: Parameter<String>) -> Verify { return Verify(method: .m_didChangeFormula__formula(`formula`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `formula` label")
		static func didChangeFormula(formula: Parameter<String>) -> Verify { return Verify(method: .m_didChangeFormula__formula(`formula`))}
        static func didCalculateFormula(_ value: Parameter<Decimal>) -> Verify { return Verify(method: .m_didCalculateFormula__value(`value`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `value` label")
		static func didCalculateFormula(value: Parameter<Decimal>) -> Verify { return Verify(method: .m_didCalculateFormula__value(`value`))}
        static func didConfirm() -> Verify { return Verify(method: .m_didConfirm)}
        static func didChangeMosaicWithXem(_ withXem: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeMosaicWithXem__withXem(`withXem`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `withXem` label")
		static func didChangeMosaicWithXem(withXem: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeMosaicWithXem__withXem(`withXem`))}
        static func didSelectMosaicOwned(_ mosaic: Parameter<MosaicDetail>) -> Verify { return Verify(method: .m_didSelectMosaicOwned__mosaic(`mosaic`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didSelectMosaicOwned(mosaic: Parameter<MosaicDetail>) -> Verify { return Verify(method: .m_didSelectMosaicOwned__mosaic(`mosaic`))}
        static func didDeselectMosaicOwned(_ mosaic: Parameter<MosaicDetail>) -> Verify { return Verify(method: .m_didDeselectMosaicOwned__mosaic(`mosaic`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didDeselectMosaicOwned(mosaic: Parameter<MosaicDetail>) -> Verify { return Verify(method: .m_didDeselectMosaicOwned__mosaic(`mosaic`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendAmountView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendAmountUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendAmountWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickMosaicTab(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickMosaicTab, performs: perform)
        }
        static func didClickAmountTab(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickAmountTab, performs: perform)
        }
        static func didChangeAmountPage(_ pageIndex: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didChangeAmountPage__pageIndex(`pageIndex`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pageIndex` label")
		static func didChangeAmountPage(pageIndex: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didChangeAmountPage__pageIndex(`pageIndex`), performs: perform)
        }
        static func didChangeFormula(_ formula: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didChangeFormula__formula(`formula`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `formula` label")
		static func didChangeFormula(formula: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didChangeFormula__formula(`formula`), performs: perform)
        }
        static func didCalculateFormula(_ value: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_didCalculateFormula__value(`value`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `value` label")
		static func didCalculateFormula(value: Parameter<Decimal>, perform: @escaping (Decimal) -> Void) -> Perform {
            return Perform(method: .m_didCalculateFormula__value(`value`), performs: perform)
        }
        static func didConfirm(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didConfirm, performs: perform)
        }
        static func didChangeMosaicWithXem(_ withXem: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeMosaicWithXem__withXem(`withXem`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `withXem` label")
		static func didChangeMosaicWithXem(withXem: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeMosaicWithXem__withXem(`withXem`), performs: perform)
        }
        static func didSelectMosaicOwned(_ mosaic: Parameter<MosaicDetail>, perform: @escaping (MosaicDetail) -> Void) -> Perform {
            return Perform(method: .m_didSelectMosaicOwned__mosaic(`mosaic`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didSelectMosaicOwned(mosaic: Parameter<MosaicDetail>, perform: @escaping (MosaicDetail) -> Void) -> Perform {
            return Perform(method: .m_didSelectMosaicOwned__mosaic(`mosaic`), performs: perform)
        }
        static func didDeselectMosaicOwned(_ mosaic: Parameter<MosaicDetail>, perform: @escaping (MosaicDetail) -> Void) -> Perform {
            return Perform(method: .m_didDeselectMosaicOwned__mosaic(`mosaic`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaic` label")
		static func didDeselectMosaicOwned(mosaic: Parameter<MosaicDetail>, perform: @escaping (MosaicDetail) -> Void) -> Perform {
            return Perform(method: .m_didDeselectMosaicOwned__mosaic(`mosaic`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendAmountUseCase
class SendAmountUseCaseMock: SendAmountUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendAmountInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendAmountUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendAmountInteractorOutput)?





    func fetchMosaicOwned(_ address: String) {
        addInvocation(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_fetchMosaicOwned__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }

    func fetchRate(_ currency: Currency) {
        addInvocation(.m_fetchRate__currency(Parameter<Currency>.value(`currency`)))
		let perform = methodPerformValue(.m_fetchRate__currency(Parameter<Currency>.value(`currency`))) as? (Currency) -> Void
		perform?(`currency`)
    }


    fileprivate enum MethodType {
        case m_fetchMosaicOwned__address(Parameter<String>)
        case m_fetchRate__currency(Parameter<Currency>)
        case p_output_get
		case p_output_set(Parameter<SendAmountInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchMosaicOwned__address(let lhsAddress), .m_fetchMosaicOwned__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.m_fetchRate__currency(let lhsCurrency), .m_fetchRate__currency(let rhsCurrency)):
                guard Parameter.compare(lhs: lhsCurrency, rhs: rhsCurrency, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendAmountInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchMosaicOwned__address(p0): return p0.intValue
            case let .m_fetchRate__currency(p0): return p0.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendAmountInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchMosaicOwned(_ address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>) -> Verify { return Verify(method: .m_fetchMosaicOwned__address(`address`))}
        static func fetchRate(_ currency: Parameter<Currency>) -> Verify { return Verify(method: .m_fetchRate__currency(`currency`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `currency` label")
		static func fetchRate(currency: Parameter<Currency>) -> Verify { return Verify(method: .m_fetchRate__currency(`currency`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendAmountInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchMosaicOwned(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchMosaicOwned(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicOwned__address(`address`), performs: perform)
        }
        static func fetchRate(_ currency: Parameter<Currency>, perform: @escaping (Currency) -> Void) -> Perform {
            return Perform(method: .m_fetchRate__currency(`currency`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `currency` label")
		static func fetchRate(currency: Parameter<Currency>, perform: @escaping (Currency) -> Void) -> Perform {
            return Perform(method: .m_fetchRate__currency(`currency`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendAmountView
class SendAmountViewMock: SendAmountView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendAmountPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendAmountViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendAmountPresentation)?





    func showAmount() {
        addInvocation(.m_showAmount)
		let perform = methodPerformValue(.m_showAmount) as? () -> Void
		perform?()
    }

    func showMosaic() {
        addInvocation(.m_showMosaic)
		let perform = methodPerformValue(.m_showMosaic) as? () -> Void
		perform?()
    }

    func showFirstAmountPage() {
        addInvocation(.m_showFirstAmountPage)
		let perform = methodPerformValue(.m_showFirstAmountPage) as? () -> Void
		perform?()
    }

    func setSendMosaicDescriptions(_ mosaicDescriptions: [SendMosaicDescription]) {
        addInvocation(.m_setSendMosaicDescriptions__mosaicDescriptions(Parameter<[SendMosaicDescription]>.value(`mosaicDescriptions`)))
		let perform = methodPerformValue(.m_setSendMosaicDescriptions__mosaicDescriptions(Parameter<[SendMosaicDescription]>.value(`mosaicDescriptions`))) as? ([SendMosaicDescription]) -> Void
		perform?(`mosaicDescriptions`)
    }

    func setFormula(_ formula: String) {
        addInvocation(.m_setFormula__formula(Parameter<String>.value(`formula`)))
		let perform = methodPerformValue(.m_setFormula__formula(Parameter<String>.value(`formula`))) as? (String) -> Void
		perform?(`formula`)
    }

    func showLoading() {
        addInvocation(.m_showLoading)
		let perform = methodPerformValue(.m_showLoading) as? () -> Void
		perform?()
    }

    func showMosaicWithXem() {
        addInvocation(.m_showMosaicWithXem)
		let perform = methodPerformValue(.m_showMosaicWithXem) as? () -> Void
		perform?()
    }

    func hideMosaicWithXem(animated: Bool) {
        addInvocation(.m_hideMosaicWithXem__animated_animated(Parameter<Bool>.value(`animated`)))
		let perform = methodPerformValue(.m_hideMosaicWithXem__animated_animated(Parameter<Bool>.value(`animated`))) as? (Bool) -> Void
		perform?(`animated`)
    }

    func showMosaicOwned(_ mosaics: [MosaicDetail], selected: [MosaicDetail]) {
        addInvocation(.m_showMosaicOwned__mosaicsselected_selected(Parameter<[MosaicDetail]>.value(`mosaics`), Parameter<[MosaicDetail]>.value(`selected`)))
		let perform = methodPerformValue(.m_showMosaicOwned__mosaicsselected_selected(Parameter<[MosaicDetail]>.value(`mosaics`), Parameter<[MosaicDetail]>.value(`selected`))) as? ([MosaicDetail], [MosaicDetail]) -> Void
		perform?(`mosaics`, `selected`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showAmount
        case m_showMosaic
        case m_showFirstAmountPage
        case m_setSendMosaicDescriptions__mosaicDescriptions(Parameter<[SendMosaicDescription]>)
        case m_setFormula__formula(Parameter<String>)
        case m_showLoading
        case m_showMosaicWithXem
        case m_hideMosaicWithXem__animated_animated(Parameter<Bool>)
        case m_showMosaicOwned__mosaicsselected_selected(Parameter<[MosaicDetail]>, Parameter<[MosaicDetail]>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendAmountPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showAmount, .m_showAmount):
                return true 
            case (.m_showMosaic, .m_showMosaic):
                return true 
            case (.m_showFirstAmountPage, .m_showFirstAmountPage):
                return true 
            case (.m_setSendMosaicDescriptions__mosaicDescriptions(let lhsMosaicdescriptions), .m_setSendMosaicDescriptions__mosaicDescriptions(let rhsMosaicdescriptions)):
                guard Parameter.compare(lhs: lhsMosaicdescriptions, rhs: rhsMosaicdescriptions, with: matcher) else { return false } 
                return true 
            case (.m_setFormula__formula(let lhsFormula), .m_setFormula__formula(let rhsFormula)):
                guard Parameter.compare(lhs: lhsFormula, rhs: rhsFormula, with: matcher) else { return false } 
                return true 
            case (.m_showLoading, .m_showLoading):
                return true 
            case (.m_showMosaicWithXem, .m_showMosaicWithXem):
                return true 
            case (.m_hideMosaicWithXem__animated_animated(let lhsAnimated), .m_hideMosaicWithXem__animated_animated(let rhsAnimated)):
                guard Parameter.compare(lhs: lhsAnimated, rhs: rhsAnimated, with: matcher) else { return false } 
                return true 
            case (.m_showMosaicOwned__mosaicsselected_selected(let lhsMosaics, let lhsSelected), .m_showMosaicOwned__mosaicsselected_selected(let rhsMosaics, let rhsSelected)):
                guard Parameter.compare(lhs: lhsMosaics, rhs: rhsMosaics, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsSelected, rhs: rhsSelected, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendAmountPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showAmount: return 0
            case .m_showMosaic: return 0
            case .m_showFirstAmountPage: return 0
            case let .m_setSendMosaicDescriptions__mosaicDescriptions(p0): return p0.intValue
            case let .m_setFormula__formula(p0): return p0.intValue
            case .m_showLoading: return 0
            case .m_showMosaicWithXem: return 0
            case let .m_hideMosaicWithXem__animated_animated(p0): return p0.intValue
            case let .m_showMosaicOwned__mosaicsselected_selected(p0, p1): return p0.intValue + p1.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendAmountPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showAmount() -> Verify { return Verify(method: .m_showAmount)}
        static func showMosaic() -> Verify { return Verify(method: .m_showMosaic)}
        static func showFirstAmountPage() -> Verify { return Verify(method: .m_showFirstAmountPage)}
        static func setSendMosaicDescriptions(_ mosaicDescriptions: Parameter<[SendMosaicDescription]>) -> Verify { return Verify(method: .m_setSendMosaicDescriptions__mosaicDescriptions(`mosaicDescriptions`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicDescriptions` label")
		static func setSendMosaicDescriptions(mosaicDescriptions: Parameter<[SendMosaicDescription]>) -> Verify { return Verify(method: .m_setSendMosaicDescriptions__mosaicDescriptions(`mosaicDescriptions`))}
        static func setFormula(_ formula: Parameter<String>) -> Verify { return Verify(method: .m_setFormula__formula(`formula`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `formula` label")
		static func setFormula(formula: Parameter<String>) -> Verify { return Verify(method: .m_setFormula__formula(`formula`))}
        static func showLoading() -> Verify { return Verify(method: .m_showLoading)}
        static func showMosaicWithXem() -> Verify { return Verify(method: .m_showMosaicWithXem)}
        static func hideMosaicWithXem(animated: Parameter<Bool>) -> Verify { return Verify(method: .m_hideMosaicWithXem__animated_animated(`animated`))}
        static func showMosaicOwned(_ mosaics: Parameter<[MosaicDetail]>, selected: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_showMosaicOwned__mosaicsselected_selected(`mosaics`, `selected`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaicOwned(mosaics: Parameter<[MosaicDetail]>, selected: Parameter<[MosaicDetail]>) -> Verify { return Verify(method: .m_showMosaicOwned__mosaicsselected_selected(`mosaics`, `selected`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendAmountPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showAmount(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showAmount, performs: perform)
        }
        static func showMosaic(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showMosaic, performs: perform)
        }
        static func showFirstAmountPage(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showFirstAmountPage, performs: perform)
        }
        static func setSendMosaicDescriptions(_ mosaicDescriptions: Parameter<[SendMosaicDescription]>, perform: @escaping ([SendMosaicDescription]) -> Void) -> Perform {
            return Perform(method: .m_setSendMosaicDescriptions__mosaicDescriptions(`mosaicDescriptions`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicDescriptions` label")
		static func setSendMosaicDescriptions(mosaicDescriptions: Parameter<[SendMosaicDescription]>, perform: @escaping ([SendMosaicDescription]) -> Void) -> Perform {
            return Perform(method: .m_setSendMosaicDescriptions__mosaicDescriptions(`mosaicDescriptions`), performs: perform)
        }
        static func setFormula(_ formula: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_setFormula__formula(`formula`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `formula` label")
		static func setFormula(formula: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_setFormula__formula(`formula`), performs: perform)
        }
        static func showLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoading, performs: perform)
        }
        static func showMosaicWithXem(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showMosaicWithXem, performs: perform)
        }
        static func hideMosaicWithXem(animated: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_hideMosaicWithXem__animated_animated(`animated`), performs: perform)
        }
        static func showMosaicOwned(_ mosaics: Parameter<[MosaicDetail]>, selected: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail], [MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_showMosaicOwned__mosaicsselected_selected(`mosaics`, `selected`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaics` label")
		static func showMosaicOwned(mosaics: Parameter<[MosaicDetail]>, selected: Parameter<[MosaicDetail]>, perform: @escaping ([MosaicDetail], [MosaicDetail]) -> Void) -> Perform {
            return Perform(method: .m_showMosaicOwned__mosaicsselected_selected(`mosaics`, `selected`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendAmountWireframe
class SendAmountWireframeMock: SendAmountWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendAmountWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ sendTransaction: SendTransaction) -> UIViewController {
        addInvocation(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ sendTransaction: SendTransaction). Use given")
		}
		return __value
    }

    func presentSendMode(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendMode__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendMode__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__sendTransaction(Parameter<SendTransaction>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__sendTransaction(let lhsSendtransaction), .sm_assembleModule__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__sendTransaction(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendMode__sendTransaction(Parameter<SendTransaction>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendMode__sendTransaction(let lhsSendtransaction), .m_presentSendMode__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentSendMode__sendTransaction(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendMode(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMode__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMode(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMode__sendTransaction(`sendTransaction`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendMode(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMode__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMode(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMode__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendConfirmationInteractorOutput
class SendConfirmationInteractorOutputMock: SendConfirmationInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func mosaicSupplyListFetched(_ mosaicSupplyList: [MosaicSupply]) {
        addInvocation(.m_mosaicSupplyListFetched__mosaicSupplyList(Parameter<[MosaicSupply]>.value(`mosaicSupplyList`)))
		let perform = methodPerformValue(.m_mosaicSupplyListFetched__mosaicSupplyList(Parameter<[MosaicSupply]>.value(`mosaicSupplyList`))) as? ([MosaicSupply]) -> Void
		perform?(`mosaicSupplyList`)
    }

    func mosaicSupplyListFetchFailed(_ error: Error) {
        addInvocation(.m_mosaicSupplyListFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_mosaicSupplyListFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }

    func transactionSent(_ result: NemAnnounceResult) {
        addInvocation(.m_transactionSent__result(Parameter<NemAnnounceResult>.value(`result`)))
		let perform = methodPerformValue(.m_transactionSent__result(Parameter<NemAnnounceResult>.value(`result`))) as? (NemAnnounceResult) -> Void
		perform?(`result`)
    }

    func transactionSendFailed(_ error: Error) {
        addInvocation(.m_transactionSendFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_transactionSendFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_mosaicSupplyListFetched__mosaicSupplyList(Parameter<[MosaicSupply]>)
        case m_mosaicSupplyListFetchFailed__error(Parameter<Error>)
        case m_transactionSent__result(Parameter<NemAnnounceResult>)
        case m_transactionSendFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_mosaicSupplyListFetched__mosaicSupplyList(let lhsMosaicsupplylist), .m_mosaicSupplyListFetched__mosaicSupplyList(let rhsMosaicsupplylist)):
                guard Parameter.compare(lhs: lhsMosaicsupplylist, rhs: rhsMosaicsupplylist, with: matcher) else { return false } 
                return true 
            case (.m_mosaicSupplyListFetchFailed__error(let lhsError), .m_mosaicSupplyListFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            case (.m_transactionSent__result(let lhsResult), .m_transactionSent__result(let rhsResult)):
                guard Parameter.compare(lhs: lhsResult, rhs: rhsResult, with: matcher) else { return false } 
                return true 
            case (.m_transactionSendFailed__error(let lhsError), .m_transactionSendFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_mosaicSupplyListFetched__mosaicSupplyList(p0): return p0.intValue
            case let .m_mosaicSupplyListFetchFailed__error(p0): return p0.intValue
            case let .m_transactionSent__result(p0): return p0.intValue
            case let .m_transactionSendFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func mosaicSupplyListFetched(_ mosaicSupplyList: Parameter<[MosaicSupply]>) -> Verify { return Verify(method: .m_mosaicSupplyListFetched__mosaicSupplyList(`mosaicSupplyList`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicSupplyList` label")
		static func mosaicSupplyListFetched(mosaicSupplyList: Parameter<[MosaicSupply]>) -> Verify { return Verify(method: .m_mosaicSupplyListFetched__mosaicSupplyList(`mosaicSupplyList`))}
        static func mosaicSupplyListFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicSupplyListFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicSupplyListFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_mosaicSupplyListFetchFailed__error(`error`))}
        static func transactionSent(_ result: Parameter<NemAnnounceResult>) -> Verify { return Verify(method: .m_transactionSent__result(`result`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label")
		static func transactionSent(result: Parameter<NemAnnounceResult>) -> Verify { return Verify(method: .m_transactionSent__result(`result`))}
        static func transactionSendFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_transactionSendFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func transactionSendFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_transactionSendFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func mosaicSupplyListFetched(_ mosaicSupplyList: Parameter<[MosaicSupply]>, perform: @escaping ([MosaicSupply]) -> Void) -> Perform {
            return Perform(method: .m_mosaicSupplyListFetched__mosaicSupplyList(`mosaicSupplyList`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicSupplyList` label")
		static func mosaicSupplyListFetched(mosaicSupplyList: Parameter<[MosaicSupply]>, perform: @escaping ([MosaicSupply]) -> Void) -> Perform {
            return Perform(method: .m_mosaicSupplyListFetched__mosaicSupplyList(`mosaicSupplyList`), performs: perform)
        }
        static func mosaicSupplyListFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicSupplyListFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func mosaicSupplyListFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_mosaicSupplyListFetchFailed__error(`error`), performs: perform)
        }
        static func transactionSent(_ result: Parameter<NemAnnounceResult>, perform: @escaping (NemAnnounceResult) -> Void) -> Perform {
            return Perform(method: .m_transactionSent__result(`result`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `result` label")
		static func transactionSent(result: Parameter<NemAnnounceResult>, perform: @escaping (NemAnnounceResult) -> Void) -> Perform {
            return Perform(method: .m_transactionSent__result(`result`), performs: perform)
        }
        static func transactionSendFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_transactionSendFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func transactionSendFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_transactionSendFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendConfirmationPresentation
class SendConfirmationPresentationMock: SendConfirmationPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendConfirmationView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendConfirmationPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendConfirmationView)?

    var interactor: SendConfirmationUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendConfirmationPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendConfirmationUseCase)?

    var router: SendConfirmationWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendConfirmationPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendConfirmationWireframe)?





    func didClickNeverRemind() {
        addInvocation(.m_didClickNeverRemind)
		let perform = methodPerformValue(.m_didClickNeverRemind) as? () -> Void
		perform?()
    }

    func didClickBottomPanel() {
        addInvocation(.m_didClickBottomPanel)
		let perform = methodPerformValue(.m_didClickBottomPanel) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }

    func didRegisterPin(_ pin: String) {
        addInvocation(.m_didRegisterPin__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didRegisterPin__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didValidatePin(_ pin: String) {
        addInvocation(.m_didValidatePin__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didValidatePin__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didCancelPin() {
        addInvocation(.m_didCancelPin)
		let perform = methodPerformValue(.m_didCancelPin) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickNeverRemind
        case m_didClickBottomPanel
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case m_didRegisterPin__pin(Parameter<String>)
        case m_didValidatePin__pin(Parameter<String>)
        case m_didCancelPin
        case p_view_get
		case p_view_set(Parameter<SendConfirmationView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendConfirmationUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendConfirmationWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickNeverRemind, .m_didClickNeverRemind):
                return true 
            case (.m_didClickBottomPanel, .m_didClickBottomPanel):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.m_didRegisterPin__pin(let lhsPin), .m_didRegisterPin__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didValidatePin__pin(let lhsPin), .m_didValidatePin__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didCancelPin, .m_didCancelPin):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendConfirmationView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendConfirmationUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendConfirmationWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickNeverRemind: return 0
            case .m_didClickBottomPanel: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case let .m_didRegisterPin__pin(p0): return p0.intValue
            case let .m_didValidatePin__pin(p0): return p0.intValue
            case .m_didCancelPin: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendConfirmationView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendConfirmationUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendConfirmationWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickNeverRemind() -> Verify { return Verify(method: .m_didClickNeverRemind)}
        static func didClickBottomPanel() -> Verify { return Verify(method: .m_didClickBottomPanel)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static func didRegisterPin(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        static func didValidatePin(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePin__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePin(pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePin__pin(`pin`))}
        static func didCancelPin() -> Verify { return Verify(method: .m_didCancelPin)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendConfirmationView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendConfirmationUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendConfirmationWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickNeverRemind(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickNeverRemind, performs: perform)
        }
        static func didClickBottomPanel(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickBottomPanel, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
        static func didRegisterPin(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        static func didValidatePin(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePin__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePin(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePin__pin(`pin`), performs: perform)
        }
        static func didCancelPin(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didCancelPin, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendConfirmationUseCase
class SendConfirmationUseCaseMock: SendConfirmationUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendConfirmationInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendConfirmationUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendConfirmationInteractorOutput)?





    func fetchMosaicSupply(_ mosaicIds: [MosaicId]) {
        addInvocation(.m_fetchMosaicSupply__mosaicIds(Parameter<[MosaicId]>.value(`mosaicIds`)))
		let perform = methodPerformValue(.m_fetchMosaicSupply__mosaicIds(Parameter<[MosaicId]>.value(`mosaicIds`))) as? ([MosaicId]) -> Void
		perform?(`mosaicIds`)
    }

    func sendTransaction(_ request: [UInt8], _ keyPair: KeyPair) {
        addInvocation(.m_sendTransaction__request_keyPair(Parameter<[UInt8]>.value(`request`), Parameter<KeyPair>.value(`keyPair`)))
		let perform = methodPerformValue(.m_sendTransaction__request_keyPair(Parameter<[UInt8]>.value(`request`), Parameter<KeyPair>.value(`keyPair`))) as? ([UInt8], KeyPair) -> Void
		perform?(`request`, `keyPair`)
    }


    fileprivate enum MethodType {
        case m_fetchMosaicSupply__mosaicIds(Parameter<[MosaicId]>)
        case m_sendTransaction__request_keyPair(Parameter<[UInt8]>, Parameter<KeyPair>)
        case p_output_get
		case p_output_set(Parameter<SendConfirmationInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchMosaicSupply__mosaicIds(let lhsMosaicids), .m_fetchMosaicSupply__mosaicIds(let rhsMosaicids)):
                guard Parameter.compare(lhs: lhsMosaicids, rhs: rhsMosaicids, with: matcher) else { return false } 
                return true 
            case (.m_sendTransaction__request_keyPair(let lhsRequest, let lhsKeypair), .m_sendTransaction__request_keyPair(let rhsRequest, let rhsKeypair)):
                guard Parameter.compare(lhs: lhsRequest, rhs: rhsRequest, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsKeypair, rhs: rhsKeypair, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendConfirmationInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchMosaicSupply__mosaicIds(p0): return p0.intValue
            case let .m_sendTransaction__request_keyPair(p0, p1): return p0.intValue + p1.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendConfirmationInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchMosaicSupply(_ mosaicIds: Parameter<[MosaicId]>) -> Verify { return Verify(method: .m_fetchMosaicSupply__mosaicIds(`mosaicIds`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicIds` label")
		static func fetchMosaicSupply(mosaicIds: Parameter<[MosaicId]>) -> Verify { return Verify(method: .m_fetchMosaicSupply__mosaicIds(`mosaicIds`))}
        static func sendTransaction(_ request: Parameter<[UInt8]>, _ keyPair: Parameter<KeyPair>) -> Verify { return Verify(method: .m_sendTransaction__request_keyPair(`request`, `keyPair`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `request` label, remove `keyPair` label")
		static func sendTransaction(request: Parameter<[UInt8]>, keyPair: Parameter<KeyPair>) -> Verify { return Verify(method: .m_sendTransaction__request_keyPair(`request`, `keyPair`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendConfirmationInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchMosaicSupply(_ mosaicIds: Parameter<[MosaicId]>, perform: @escaping ([MosaicId]) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicSupply__mosaicIds(`mosaicIds`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `mosaicIds` label")
		static func fetchMosaicSupply(mosaicIds: Parameter<[MosaicId]>, perform: @escaping ([MosaicId]) -> Void) -> Perform {
            return Perform(method: .m_fetchMosaicSupply__mosaicIds(`mosaicIds`), performs: perform)
        }
        static func sendTransaction(_ request: Parameter<[UInt8]>, _ keyPair: Parameter<KeyPair>, perform: @escaping ([UInt8], KeyPair) -> Void) -> Perform {
            return Perform(method: .m_sendTransaction__request_keyPair(`request`, `keyPair`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `request` label, remove `keyPair` label")
		static func sendTransaction(request: Parameter<[UInt8]>, keyPair: Parameter<KeyPair>, perform: @escaping ([UInt8], KeyPair) -> Void) -> Perform {
            return Perform(method: .m_sendTransaction__request_keyPair(`request`, `keyPair`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendConfirmationView
class SendConfirmationViewMock: SendConfirmationView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendConfirmationPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendConfirmationViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendConfirmationPresentation)?





    func showCaution() {
        addInvocation(.m_showCaution)
		let perform = methodPerformValue(.m_showCaution) as? () -> Void
		perform?()
    }

    func showAmounts(_ amounts: [String]) {
        addInvocation(.m_showAmounts__amounts(Parameter<[String]>.value(`amounts`)))
		let perform = methodPerformValue(.m_showAmounts__amounts(Parameter<[String]>.value(`amounts`))) as? ([String]) -> Void
		perform?(`amounts`)
    }

    func showFee(_ fee: String) {
        addInvocation(.m_showFee__fee(Parameter<String>.value(`fee`)))
		let perform = methodPerformValue(.m_showFee__fee(Parameter<String>.value(`fee`))) as? (String) -> Void
		perform?(`fee`)
    }

    func showDestination(_ destination: String, _ namespace: String) {
        addInvocation(.m_showDestination__destination_namespace(Parameter<String>.value(`destination`), Parameter<String>.value(`namespace`)))
		let perform = methodPerformValue(.m_showDestination__destination_namespace(Parameter<String>.value(`destination`), Parameter<String>.value(`namespace`))) as? (String, String) -> Void
		perform?(`destination`, `namespace`)
    }

    func showMessage(_ message: String) {
        addInvocation(.m_showMessage__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showMessage__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showLoading() {
        addInvocation(.m_showLoading)
		let perform = methodPerformValue(.m_showLoading) as? () -> Void
		perform?()
    }

    func hideLoading() {
        addInvocation(.m_hideLoading)
		let perform = methodPerformValue(.m_hideLoading) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showPinDialog(presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (PinDialogMixinPresentation) -> Void
		perform?(`presenter`)
    }

    func showPinDialog(forRegistration: Bool,presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (Bool, PinDialogMixinPresentation) -> Void
		perform?(`forRegistration`, `presenter`)
    }

    func showPinDialog(forRegistration: Bool, cancelable: Bool, presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (Bool, Bool, PinDialogMixinPresentation) -> Void
		perform?(`forRegistration`, `cancelable`, `presenter`)
    }


    fileprivate enum MethodType {
        case m_showCaution
        case m_showAmounts__amounts(Parameter<[String]>)
        case m_showFee__fee(Parameter<String>)
        case m_showDestination__destination_namespace(Parameter<String>, Parameter<String>)
        case m_showMessage__message(Parameter<String>)
        case m_showLoading
        case m_hideLoading
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>)
        case m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>, Parameter<PinDialogMixinPresentation>)
        case m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>, Parameter<Bool>, Parameter<PinDialogMixinPresentation>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendConfirmationPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showCaution, .m_showCaution):
                return true 
            case (.m_showAmounts__amounts(let lhsAmounts), .m_showAmounts__amounts(let rhsAmounts)):
                guard Parameter.compare(lhs: lhsAmounts, rhs: rhsAmounts, with: matcher) else { return false } 
                return true 
            case (.m_showFee__fee(let lhsFee), .m_showFee__fee(let rhsFee)):
                guard Parameter.compare(lhs: lhsFee, rhs: rhsFee, with: matcher) else { return false } 
                return true 
            case (.m_showDestination__destination_namespace(let lhsDestination, let lhsNamespace), .m_showDestination__destination_namespace(let rhsDestination, let rhsNamespace)):
                guard Parameter.compare(lhs: lhsDestination, rhs: rhsDestination, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsNamespace, rhs: rhsNamespace, with: matcher) else { return false } 
                return true 
            case (.m_showMessage__message(let lhsMessage), .m_showMessage__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showLoading, .m_showLoading):
                return true 
            case (.m_hideLoading, .m_hideLoading):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__presenter_presenter(let lhsPresenter), .m_showPinDialog__presenter_presenter(let rhsPresenter)):
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(let lhsForregistration, let lhsPresenter), .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(let rhsForregistration, let rhsPresenter)):
                guard Parameter.compare(lhs: lhsForregistration, rhs: rhsForregistration, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(let lhsForregistration, let lhsCancelable, let lhsPresenter), .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(let rhsForregistration, let rhsCancelable, let rhsPresenter)):
                guard Parameter.compare(lhs: lhsForregistration, rhs: rhsForregistration, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCancelable, rhs: rhsCancelable, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendConfirmationPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showCaution: return 0
            case let .m_showAmounts__amounts(p0): return p0.intValue
            case let .m_showFee__fee(p0): return p0.intValue
            case let .m_showDestination__destination_namespace(p0, p1): return p0.intValue + p1.intValue
            case let .m_showMessage__message(p0): return p0.intValue
            case .m_showLoading: return 0
            case .m_hideLoading: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case let .m_showPinDialog__presenter_presenter(p0): return p0.intValue
            case let .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(p0, p1): return p0.intValue + p1.intValue
            case let .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendConfirmationPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showCaution() -> Verify { return Verify(method: .m_showCaution)}
        static func showAmounts(_ amounts: Parameter<[String]>) -> Verify { return Verify(method: .m_showAmounts__amounts(`amounts`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `amounts` label")
		static func showAmounts(amounts: Parameter<[String]>) -> Verify { return Verify(method: .m_showAmounts__amounts(`amounts`))}
        static func showFee(_ fee: Parameter<String>) -> Verify { return Verify(method: .m_showFee__fee(`fee`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `fee` label")
		static func showFee(fee: Parameter<String>) -> Verify { return Verify(method: .m_showFee__fee(`fee`))}
        static func showDestination(_ destination: Parameter<String>, _ namespace: Parameter<String>) -> Verify { return Verify(method: .m_showDestination__destination_namespace(`destination`, `namespace`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `destination` label, remove `namespace` label")
		static func showDestination(destination: Parameter<String>, namespace: Parameter<String>) -> Verify { return Verify(method: .m_showDestination__destination_namespace(`destination`, `namespace`))}
        static func showMessage(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        static func showLoading() -> Verify { return Verify(method: .m_showLoading)}
        static func hideLoading() -> Verify { return Verify(method: .m_hideLoading)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static func showPinDialog(presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__presenter_presenter(`presenter`))}
        static func showPinDialog(forRegistration: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(`forRegistration`, `presenter`))}
        static func showPinDialog(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(`forRegistration`, `cancelable`, `presenter`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendConfirmationPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showCaution(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showCaution, performs: perform)
        }
        static func showAmounts(_ amounts: Parameter<[String]>, perform: @escaping ([String]) -> Void) -> Perform {
            return Perform(method: .m_showAmounts__amounts(`amounts`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `amounts` label")
		static func showAmounts(amounts: Parameter<[String]>, perform: @escaping ([String]) -> Void) -> Perform {
            return Perform(method: .m_showAmounts__amounts(`amounts`), performs: perform)
        }
        static func showFee(_ fee: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showFee__fee(`fee`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `fee` label")
		static func showFee(fee: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showFee__fee(`fee`), performs: perform)
        }
        static func showDestination(_ destination: Parameter<String>, _ namespace: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_showDestination__destination_namespace(`destination`, `namespace`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `destination` label, remove `namespace` label")
		static func showDestination(destination: Parameter<String>, namespace: Parameter<String>, perform: @escaping (String, String) -> Void) -> Perform {
            return Perform(method: .m_showDestination__destination_namespace(`destination`, `namespace`), performs: perform)
        }
        static func showMessage(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        static func showLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoading, performs: perform)
        }
        static func hideLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideLoading, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        static func showPinDialog(presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__presenter_presenter(`presenter`), performs: perform)
        }
        static func showPinDialog(forRegistration: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (Bool, PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(`forRegistration`, `presenter`), performs: perform)
        }
        static func showPinDialog(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (Bool, Bool, PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(`forRegistration`, `cancelable`, `presenter`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendConfirmationWireframe
class SendConfirmationWireframeMock: SendConfirmationWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendConfirmationWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ sendTransaction: SendTransaction) -> UIViewController {
        addInvocation(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ sendTransaction: SendTransaction). Use given")
		}
		return __value
    }

    func presentSendEnd() {
        addInvocation(.m_presentSendEnd)
		let perform = methodPerformValue(.m_presentSendEnd) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__sendTransaction(Parameter<SendTransaction>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__sendTransaction(let lhsSendtransaction), .sm_assembleModule__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__sendTransaction(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendEnd
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendEnd, .m_presentSendEnd):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentSendEnd: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendEnd() -> Verify { return Verify(method: .m_presentSendEnd)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendEnd(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSendEnd, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendEndInteractorOutput
class SendEndInteractorOutputMock: SendEndInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendEndPresentation
class SendEndPresentationMock: SendEndPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendEndView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendEndPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendEndView)?

    var interactor: SendEndUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendEndPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendEndUseCase)?

    var router: SendEndWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendEndPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendEndWireframe)?





    func didClickHome() {
        addInvocation(.m_didClickHome)
		let perform = methodPerformValue(.m_didClickHome) as? () -> Void
		perform?()
    }

    func didClickTransaction() {
        addInvocation(.m_didClickTransaction)
		let perform = methodPerformValue(.m_didClickTransaction) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickHome
        case m_didClickTransaction
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SendEndView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendEndUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendEndWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickHome, .m_didClickHome):
                return true 
            case (.m_didClickTransaction, .m_didClickTransaction):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendEndView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendEndUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendEndWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickHome: return 0
            case .m_didClickTransaction: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendEndView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendEndUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendEndWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickHome() -> Verify { return Verify(method: .m_didClickHome)}
        static func didClickTransaction() -> Verify { return Verify(method: .m_didClickTransaction)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendEndView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendEndUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendEndWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickHome(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickHome, performs: perform)
        }
        static func didClickTransaction(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickTransaction, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendEndUseCase
class SendEndUseCaseMock: SendEndUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendEndInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendEndUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendEndInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<SendEndInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendEndInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendEndInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendEndInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendEndView
class SendEndViewMock: SendEndView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendEndPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendEndViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendEndPresentation)?





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendEndPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendEndPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendEndPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendEndPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendEndWireframe
class SendEndWireframeMock: SendEndWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendEndWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func goBackHome() {
        addInvocation(.m_goBackHome)
		let perform = methodPerformValue(.m_goBackHome) as? () -> Void
		perform?()
    }

    func presentTransaction() {
        addInvocation(.m_presentTransaction)
		let perform = methodPerformValue(.m_presentTransaction) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_goBackHome
        case m_presentTransaction
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_goBackHome, .m_goBackHome):
                return true 
            case (.m_presentTransaction, .m_presentTransaction):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_goBackHome: return 0
            case .m_presentTransaction: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func goBackHome() -> Verify { return Verify(method: .m_goBackHome)}
        static func presentTransaction() -> Verify { return Verify(method: .m_presentTransaction)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func goBackHome(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_goBackHome, performs: perform)
        }
        static func presentTransaction(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentTransaction, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendMessageInteractorOutput
class SendMessageInteractorOutputMock: SendMessageInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessagePresentation
class SendMessagePresentationMock: SendMessagePresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendMessageView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendMessagePresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendMessageView)?

    var interactor: SendMessageUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendMessagePresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendMessageUseCase)?

    var router: SendMessageWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendMessagePresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendMessageWireframe)?





    func didClickOk() {
        addInvocation(.m_didClickOk)
		let perform = methodPerformValue(.m_didClickOk) as? () -> Void
		perform?()
    }

    func didClickCancel() {
        addInvocation(.m_didClickCancel)
		let perform = methodPerformValue(.m_didClickCancel) as? () -> Void
		perform?()
    }

    func didChangeMessage(_ message: String) {
        addInvocation(.m_didChangeMessage__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_didChangeMessage__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickOk
        case m_didClickCancel
        case m_didChangeMessage__message(Parameter<String>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SendMessageView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendMessageUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendMessageWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickOk, .m_didClickOk):
                return true 
            case (.m_didClickCancel, .m_didClickCancel):
                return true 
            case (.m_didChangeMessage__message(let lhsMessage), .m_didChangeMessage__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendMessageView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendMessageUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendMessageWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickOk: return 0
            case .m_didClickCancel: return 0
            case let .m_didChangeMessage__message(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendMessageView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendMessageUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendMessageWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickOk() -> Verify { return Verify(method: .m_didClickOk)}
        static func didClickCancel() -> Verify { return Verify(method: .m_didClickCancel)}
        static func didChangeMessage(_ message: Parameter<String>) -> Verify { return Verify(method: .m_didChangeMessage__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didChangeMessage(message: Parameter<String>) -> Verify { return Verify(method: .m_didChangeMessage__message(`message`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendMessageView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendMessageUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendMessageWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickOk(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOk, performs: perform)
        }
        static func didClickCancel(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickCancel, performs: perform)
        }
        static func didChangeMessage(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didChangeMessage__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didChangeMessage(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didChangeMessage__message(`message`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageTypeInteractorOutput
class SendMessageTypeInteractorOutputMock: SendMessageTypeInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageTypePresentation
class SendMessageTypePresentationMock: SendMessageTypePresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendMessageTypeView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendMessageTypePresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendMessageTypeView)?

    var interactor: SendMessageTypeUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendMessageTypePresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendMessageTypeUseCase)?

    var router: SendMessageTypeWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendMessageTypePresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendMessageTypeWireframe)?





    func didSelectPage(_ index: Int) {
        addInvocation(.m_didSelectPage__index(Parameter<Int>.value(`index`)))
		let perform = methodPerformValue(.m_didSelectPage__index(Parameter<Int>.value(`index`))) as? (Int) -> Void
		perform?(`index`)
    }

    func didClickOk() {
        addInvocation(.m_didClickOk)
		let perform = methodPerformValue(.m_didClickOk) as? () -> Void
		perform?()
    }

    func didConfirmMessage(_ message: String) {
        addInvocation(.m_didConfirmMessage__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_didConfirmMessage__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didSelectPage__index(Parameter<Int>)
        case m_didClickOk
        case m_didConfirmMessage__message(Parameter<String>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SendMessageTypeView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendMessageTypeUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendMessageTypeWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didSelectPage__index(let lhsIndex), .m_didSelectPage__index(let rhsIndex)):
                guard Parameter.compare(lhs: lhsIndex, rhs: rhsIndex, with: matcher) else { return false } 
                return true 
            case (.m_didClickOk, .m_didClickOk):
                return true 
            case (.m_didConfirmMessage__message(let lhsMessage), .m_didConfirmMessage__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendMessageTypeView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendMessageTypeUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendMessageTypeWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_didSelectPage__index(p0): return p0.intValue
            case .m_didClickOk: return 0
            case let .m_didConfirmMessage__message(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendMessageTypeView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendMessageTypeUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendMessageTypeWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didSelectPage(_ index: Parameter<Int>) -> Verify { return Verify(method: .m_didSelectPage__index(`index`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `index` label")
		static func didSelectPage(index: Parameter<Int>) -> Verify { return Verify(method: .m_didSelectPage__index(`index`))}
        static func didClickOk() -> Verify { return Verify(method: .m_didClickOk)}
        static func didConfirmMessage(_ message: Parameter<String>) -> Verify { return Verify(method: .m_didConfirmMessage__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didConfirmMessage(message: Parameter<String>) -> Verify { return Verify(method: .m_didConfirmMessage__message(`message`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendMessageTypeView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendMessageTypeUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendMessageTypeWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didSelectPage(_ index: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didSelectPage__index(`index`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `index` label")
		static func didSelectPage(index: Parameter<Int>, perform: @escaping (Int) -> Void) -> Perform {
            return Perform(method: .m_didSelectPage__index(`index`), performs: perform)
        }
        static func didClickOk(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickOk, performs: perform)
        }
        static func didConfirmMessage(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didConfirmMessage__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func didConfirmMessage(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didConfirmMessage__message(`message`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageTypeUseCase
class SendMessageTypeUseCaseMock: SendMessageTypeUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendMessageTypeInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendMessageTypeUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendMessageTypeInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<SendMessageTypeInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendMessageTypeInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendMessageTypeInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendMessageTypeInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageTypeView
class SendMessageTypeViewMock: SendMessageTypeView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendMessageTypePresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendMessageTypeViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendMessageTypePresentation)?





    func showMessageInputDialog() {
        addInvocation(.m_showMessageInputDialog)
		let perform = methodPerformValue(.m_showMessageInputDialog) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showMessageInputDialog
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendMessageTypePresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showMessageInputDialog, .m_showMessageInputDialog):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendMessageTypePresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showMessageInputDialog: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendMessageTypePresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showMessageInputDialog() -> Verify { return Verify(method: .m_showMessageInputDialog)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendMessageTypePresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showMessageInputDialog(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showMessageInputDialog, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageTypeWireframe
class SendMessageTypeWireframeMock: SendMessageTypeWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendMessageTypeWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ sendTransaction: SendTransaction) -> UIViewController {
        addInvocation(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ sendTransaction: SendTransaction). Use given")
		}
		return __value
    }

    func presentSendConfirmation(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__sendTransaction(Parameter<SendTransaction>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__sendTransaction(let lhsSendtransaction), .sm_assembleModule__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__sendTransaction(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendConfirmation__sendTransaction(let lhsSendtransaction), .m_presentSendConfirmation__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentSendConfirmation__sendTransaction(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendMessageUseCase
class SendMessageUseCaseMock: SendMessageUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendMessageInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendMessageUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendMessageInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<SendMessageInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendMessageInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendMessageInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendMessageInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageView
class SendMessageViewMock: SendMessageView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendMessagePresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendMessageViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendMessagePresentation)?





    func enableOk() {
        addInvocation(.m_enableOk)
		let perform = methodPerformValue(.m_enableOk) as? () -> Void
		perform?()
    }

    func disableOk() {
        addInvocation(.m_disableOk)
		let perform = methodPerformValue(.m_disableOk) as? () -> Void
		perform?()
    }

    func showTitle(_ title: String) {
        addInvocation(.m_showTitle__title(Parameter<String>.value(`title`)))
		let perform = methodPerformValue(.m_showTitle__title(Parameter<String>.value(`title`))) as? (String) -> Void
		perform?(`title`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_enableOk
        case m_disableOk
        case m_showTitle__title(Parameter<String>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendMessagePresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_enableOk, .m_enableOk):
                return true 
            case (.m_disableOk, .m_disableOk):
                return true 
            case (.m_showTitle__title(let lhsTitle), .m_showTitle__title(let rhsTitle)):
                guard Parameter.compare(lhs: lhsTitle, rhs: rhsTitle, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendMessagePresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_enableOk: return 0
            case .m_disableOk: return 0
            case let .m_showTitle__title(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendMessagePresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func enableOk() -> Verify { return Verify(method: .m_enableOk)}
        static func disableOk() -> Verify { return Verify(method: .m_disableOk)}
        static func showTitle(_ title: Parameter<String>) -> Verify { return Verify(method: .m_showTitle__title(`title`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `title` label")
		static func showTitle(title: Parameter<String>) -> Verify { return Verify(method: .m_showTitle__title(`title`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendMessagePresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func enableOk(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_enableOk, performs: perform)
        }
        static func disableOk(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_disableOk, performs: perform)
        }
        static func showTitle(_ title: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showTitle__title(`title`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `title` label")
		static func showTitle(title: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showTitle__title(`title`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendMessageWireframe
class SendMessageWireframeMock: SendMessageWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendMessageWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ handler: ((String?) -> Void)?) -> UIViewController {
        addInvocation(.sm_assembleModule__handler(Parameter<((String?) -> Void)?>.value(`handler`)))
		let perform = methodPerformValue(.sm_assembleModule__handler(Parameter<((String?) -> Void)?>.value(`handler`))) as? (((String?) -> Void)?) -> Void
		perform?(`handler`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__handler(Parameter<((String?) -> Void)?>.value(`handler`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ handler: ((String?) -> Void)?). Use given")
		}
		return __value
    }

    func dismiss(_ message: String?, _ handler: ((String?) -> Void)?) {
        addInvocation(.m_dismiss__message_handler(Parameter<String?>.value(`message`), Parameter<((String?) -> Void)?>.value(`handler`)))
		let perform = methodPerformValue(.m_dismiss__message_handler(Parameter<String?>.value(`message`), Parameter<((String?) -> Void)?>.value(`handler`))) as? (String?, ((String?) -> Void)?) -> Void
		perform?(`message`, `handler`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__handler(Parameter<((String?) -> Void)?>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__handler(let lhsHandler), .sm_assembleModule__handler(let rhsHandler)):
                guard Parameter.compare(lhs: lhsHandler, rhs: rhsHandler, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__handler(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ handler: Parameter<((String?) -> Void)?>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__handler(`handler`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `handler` label")
		static func assembleModule(handler: Parameter<((String?) -> Void)?>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__handler(`handler`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ handler: Parameter<((String?) -> Void)?>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__handler(`handler`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ handler: Parameter<((String?) -> Void)?>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__handler(`handler`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `handler` label")
		static func assembleModule(handler: Parameter<((String?) -> Void)?>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__handler(`handler`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ handler: Parameter<((String?) -> Void)?>, perform: @escaping (((String?) -> Void)?) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__handler(`handler`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `handler` label")
		static func assembleModule(handler: Parameter<((String?) -> Void)?>, perform: @escaping (((String?) -> Void)?) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__handler(`handler`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_dismiss__message_handler(Parameter<String?>, Parameter<((String?) -> Void)?>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_dismiss__message_handler(let lhsMessage, let lhsHandler), .m_dismiss__message_handler(let rhsMessage, let rhsHandler)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsHandler, rhs: rhsHandler, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_dismiss__message_handler(p0, p1): return p0.intValue + p1.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func dismiss(_ message: Parameter<String?>, _ handler: Parameter<((String?) -> Void)?>) -> Verify { return Verify(method: .m_dismiss__message_handler(`message`, `handler`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label, remove `handler` label")
		static func dismiss(message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>) -> Verify { return Verify(method: .m_dismiss__message_handler(`message`, `handler`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func dismiss(_ message: Parameter<String?>, _ handler: Parameter<((String?) -> Void)?>, perform: @escaping (String?, ((String?) -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__message_handler(`message`, `handler`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label, remove `handler` label")
		static func dismiss(message: Parameter<String?>, handler: Parameter<((String?) -> Void)?>, perform: @escaping (String?, ((String?) -> Void)?) -> Void) -> Perform {
            return Perform(method: .m_dismiss__message_handler(`message`, `handler`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SendModeInteractorOutput
class SendModeInteractorOutputMock: SendModeInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendModePresentation
class SendModePresentationMock: SendModePresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SendModeView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SendModePresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SendModeView)?

    var interactor: SendModeUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SendModePresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SendModeUseCase)?

    var router: SendModeWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SendModePresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SendModeWireframe)?





    func didClickAttach() {
        addInvocation(.m_didClickAttach)
		let perform = methodPerformValue(.m_didClickAttach) as? () -> Void
		perform?()
    }

    func didClickNotAttach() {
        addInvocation(.m_didClickNotAttach)
		let perform = methodPerformValue(.m_didClickNotAttach) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickAttach
        case m_didClickNotAttach
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SendModeView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SendModeUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SendModeWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickAttach, .m_didClickAttach):
                return true 
            case (.m_didClickNotAttach, .m_didClickNotAttach):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SendModeView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SendModeUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SendModeWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickAttach: return 0
            case .m_didClickNotAttach: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SendModeView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SendModeUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SendModeWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickAttach() -> Verify { return Verify(method: .m_didClickAttach)}
        static func didClickNotAttach() -> Verify { return Verify(method: .m_didClickNotAttach)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SendModeView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SendModeUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SendModeWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickAttach(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickAttach, performs: perform)
        }
        static func didClickNotAttach(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickNotAttach, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendModeUseCase
class SendModeUseCaseMock: SendModeUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SendModeInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SendModeUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SendModeInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<SendModeInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SendModeInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SendModeInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SendModeInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendModeView
class SendModeViewMock: SendModeView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SendModePresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SendModeViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SendModePresentation)?





    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SendModePresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SendModePresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SendModePresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SendModePresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SendModeWireframe
class SendModeWireframeMock: SendModeWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SendModeWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ sendTransaction: SendTransaction) -> UIViewController {
        addInvocation(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ sendTransaction: SendTransaction). Use given")
		}
		return __value
    }

    func presentSendConfirmation(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    func presentSendMessageType(_ sendTransaction: SendTransaction) {
        addInvocation(.m_presentSendMessageType__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`)))
		let perform = methodPerformValue(.m_presentSendMessageType__sendTransaction(Parameter<SendTransaction>.value(`sendTransaction`))) as? (SendTransaction) -> Void
		perform?(`sendTransaction`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__sendTransaction(Parameter<SendTransaction>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__sendTransaction(let lhsSendtransaction), .sm_assembleModule__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__sendTransaction(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__sendTransaction(`sendTransaction`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__sendTransaction(`sendTransaction`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func assembleModule(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentSendConfirmation__sendTransaction(Parameter<SendTransaction>)
        case m_presentSendMessageType__sendTransaction(Parameter<SendTransaction>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentSendConfirmation__sendTransaction(let lhsSendtransaction), .m_presentSendConfirmation__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.m_presentSendMessageType__sendTransaction(let lhsSendtransaction), .m_presentSendMessageType__sendTransaction(let rhsSendtransaction)):
                guard Parameter.compare(lhs: lhsSendtransaction, rhs: rhsSendtransaction, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentSendConfirmation__sendTransaction(p0): return p0.intValue
            case let .m_presentSendMessageType__sendTransaction(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`))}
        static func presentSendMessageType(_ sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMessageType__sendTransaction(`sendTransaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMessageType(sendTransaction: Parameter<SendTransaction>) -> Verify { return Verify(method: .m_presentSendMessageType__sendTransaction(`sendTransaction`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentSendConfirmation(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendConfirmation(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendConfirmation__sendTransaction(`sendTransaction`), performs: perform)
        }
        static func presentSendMessageType(_ sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMessageType__sendTransaction(`sendTransaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `sendTransaction` label")
		static func presentSendMessageType(sendTransaction: Parameter<SendTransaction>, perform: @escaping (SendTransaction) -> Void) -> Perform {
            return Perform(method: .m_presentSendMessageType__sendTransaction(`sendTransaction`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - SettingTopInteractorOutput
class SettingTopInteractorOutputMock: SettingTopInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }






    fileprivate struct MethodType {
        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool { return true }
        func intValue() -> Int { return 0 }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingTopPresentation
class SettingTopPresentationMock: SettingTopPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: SettingTopView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "SettingTopPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (SettingTopView)?

    var interactor: SettingTopUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "SettingTopPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (SettingTopUseCase)?

    var router: SettingTopWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "SettingTopPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (SettingTopWireframe)?





    func didClickNodeSelect() {
        addInvocation(.m_didClickNodeSelect)
		let perform = methodPerformValue(.m_didClickNodeSelect) as? () -> Void
		perform?()
    }

    func didClickLanguageSelect() {
        addInvocation(.m_didClickLanguageSelect)
		let perform = methodPerformValue(.m_didClickLanguageSelect) as? () -> Void
		perform?()
    }

    func didClickCurrencySelect() {
        addInvocation(.m_didClickCurrencySelect)
		let perform = methodPerformValue(.m_didClickCurrencySelect) as? () -> Void
		perform?()
    }

    func didClickNotificationSetting() {
        addInvocation(.m_didClickNotificationSetting)
		let perform = methodPerformValue(.m_didClickNotificationSetting) as? () -> Void
		perform?()
    }

    func didClickChangePassword() {
        addInvocation(.m_didClickChangePassword)
		let perform = methodPerformValue(.m_didClickChangePassword) as? () -> Void
		perform?()
    }

    func didRegisterPin(_ pin: String) {
        addInvocation(.m_didRegisterPin__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didRegisterPin__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didChangeIsBiometricsRequired(_ isBiometricsRequired: Bool) {
        addInvocation(.m_didChangeIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>.value(`isBiometricsRequired`)))
		let perform = methodPerformValue(.m_didChangeIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>.value(`isBiometricsRequired`))) as? (Bool) -> Void
		perform?(`isBiometricsRequired`)
    }

    func didValidatePinForBiometrics(_ pin: String) {
        addInvocation(.m_didValidatePinForBiometrics__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didValidatePinForBiometrics__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didClickEnableBiometrics() {
        addInvocation(.m_didClickEnableBiometrics)
		let perform = methodPerformValue(.m_didClickEnableBiometrics) as? () -> Void
		perform?()
    }

    func didClickCancelBiometrics() {
        addInvocation(.m_didClickCancelBiometrics)
		let perform = methodPerformValue(.m_didClickCancelBiometrics) as? () -> Void
		perform?()
    }

    func didChangeIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Bool) {
        addInvocation(.m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>.value(`isPinRequiredOnLaunch`)))
		let perform = methodPerformValue(.m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>.value(`isPinRequiredOnLaunch`))) as? (Bool) -> Void
		perform?(`isPinRequiredOnLaunch`)
    }

    func didClickGoToSecurityLesson() {
        addInvocation(.m_didClickGoToSecurityLesson)
		let perform = methodPerformValue(.m_didClickGoToSecurityLesson) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickNodeSelect
        case m_didClickLanguageSelect
        case m_didClickCurrencySelect
        case m_didClickNotificationSetting
        case m_didClickChangePassword
        case m_didRegisterPin__pin(Parameter<String>)
        case m_didChangeIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>)
        case m_didValidatePinForBiometrics__pin(Parameter<String>)
        case m_didClickEnableBiometrics
        case m_didClickCancelBiometrics
        case m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>)
        case m_didClickGoToSecurityLesson
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<SettingTopView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<SettingTopUseCase?>)
        case p_router_get
		case p_router_set(Parameter<SettingTopWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickNodeSelect, .m_didClickNodeSelect):
                return true 
            case (.m_didClickLanguageSelect, .m_didClickLanguageSelect):
                return true 
            case (.m_didClickCurrencySelect, .m_didClickCurrencySelect):
                return true 
            case (.m_didClickNotificationSetting, .m_didClickNotificationSetting):
                return true 
            case (.m_didClickChangePassword, .m_didClickChangePassword):
                return true 
            case (.m_didRegisterPin__pin(let lhsPin), .m_didRegisterPin__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didChangeIsBiometricsRequired__isBiometricsRequired(let lhsIsbiometricsrequired), .m_didChangeIsBiometricsRequired__isBiometricsRequired(let rhsIsbiometricsrequired)):
                guard Parameter.compare(lhs: lhsIsbiometricsrequired, rhs: rhsIsbiometricsrequired, with: matcher) else { return false } 
                return true 
            case (.m_didValidatePinForBiometrics__pin(let lhsPin), .m_didValidatePinForBiometrics__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didClickEnableBiometrics, .m_didClickEnableBiometrics):
                return true 
            case (.m_didClickCancelBiometrics, .m_didClickCancelBiometrics):
                return true 
            case (.m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(let lhsIspinrequiredonlaunch), .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(let rhsIspinrequiredonlaunch)):
                guard Parameter.compare(lhs: lhsIspinrequiredonlaunch, rhs: rhsIspinrequiredonlaunch, with: matcher) else { return false } 
                return true 
            case (.m_didClickGoToSecurityLesson, .m_didClickGoToSecurityLesson):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<SettingTopView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<SettingTopUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<SettingTopWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickNodeSelect: return 0
            case .m_didClickLanguageSelect: return 0
            case .m_didClickCurrencySelect: return 0
            case .m_didClickNotificationSetting: return 0
            case .m_didClickChangePassword: return 0
            case let .m_didRegisterPin__pin(p0): return p0.intValue
            case let .m_didChangeIsBiometricsRequired__isBiometricsRequired(p0): return p0.intValue
            case let .m_didValidatePinForBiometrics__pin(p0): return p0.intValue
            case .m_didClickEnableBiometrics: return 0
            case .m_didClickCancelBiometrics: return 0
            case let .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(p0): return p0.intValue
            case .m_didClickGoToSecurityLesson: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: SettingTopView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: SettingTopUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: SettingTopWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickNodeSelect() -> Verify { return Verify(method: .m_didClickNodeSelect)}
        static func didClickLanguageSelect() -> Verify { return Verify(method: .m_didClickLanguageSelect)}
        static func didClickCurrencySelect() -> Verify { return Verify(method: .m_didClickCurrencySelect)}
        static func didClickNotificationSetting() -> Verify { return Verify(method: .m_didClickNotificationSetting)}
        static func didClickChangePassword() -> Verify { return Verify(method: .m_didClickChangePassword)}
        static func didRegisterPin(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        static func didChangeIsBiometricsRequired(_ isBiometricsRequired: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isBiometricsRequired` label")
		static func didChangeIsBiometricsRequired(isBiometricsRequired: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`))}
        static func didValidatePinForBiometrics(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePinForBiometrics__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePinForBiometrics(pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePinForBiometrics__pin(`pin`))}
        static func didClickEnableBiometrics() -> Verify { return Verify(method: .m_didClickEnableBiometrics)}
        static func didClickCancelBiometrics() -> Verify { return Verify(method: .m_didClickCancelBiometrics)}
        static func didChangeIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPinRequiredOnLaunch` label")
		static func didChangeIsPinRequiredOnLaunch(isPinRequiredOnLaunch: Parameter<Bool>) -> Verify { return Verify(method: .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`))}
        static func didClickGoToSecurityLesson() -> Verify { return Verify(method: .m_didClickGoToSecurityLesson)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<SettingTopView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<SettingTopUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<SettingTopWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickNodeSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickNodeSelect, performs: perform)
        }
        static func didClickLanguageSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickLanguageSelect, performs: perform)
        }
        static func didClickCurrencySelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickCurrencySelect, performs: perform)
        }
        static func didClickNotificationSetting(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickNotificationSetting, performs: perform)
        }
        static func didClickChangePassword(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickChangePassword, performs: perform)
        }
        static func didRegisterPin(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        static func didChangeIsBiometricsRequired(_ isBiometricsRequired: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isBiometricsRequired` label")
		static func didChangeIsBiometricsRequired(isBiometricsRequired: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`), performs: perform)
        }
        static func didValidatePinForBiometrics(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePinForBiometrics__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePinForBiometrics(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePinForBiometrics__pin(`pin`), performs: perform)
        }
        static func didClickEnableBiometrics(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickEnableBiometrics, performs: perform)
        }
        static func didClickCancelBiometrics(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickCancelBiometrics, performs: perform)
        }
        static func didChangeIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPinRequiredOnLaunch` label")
		static func didChangeIsPinRequiredOnLaunch(isPinRequiredOnLaunch: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_didChangeIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`), performs: perform)
        }
        static func didClickGoToSecurityLesson(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickGoToSecurityLesson, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingTopUseCase
class SettingTopUseCaseMock: SettingTopUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: SettingTopInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "SettingTopUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (SettingTopInteractorOutput)?






    fileprivate enum MethodType {
        case p_output_get
		case p_output_set(Parameter<SettingTopInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<SettingTopInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: SettingTopInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<SettingTopInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingTopView
class SettingTopViewMock: SettingTopView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: SettingTopPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "SettingTopViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (SettingTopPresentation)?





    func showPinDialogForRegistration() {
        addInvocation(.m_showPinDialogForRegistration)
		let perform = methodPerformValue(.m_showPinDialogForRegistration) as? () -> Void
		perform?()
    }

    func showPinDialogForBiometrics() {
        addInvocation(.m_showPinDialogForBiometrics)
		let perform = methodPerformValue(.m_showPinDialogForBiometrics) as? () -> Void
		perform?()
    }

    func showBiometricsEnableDialog() {
        addInvocation(.m_showBiometricsEnableDialog)
		let perform = methodPerformValue(.m_showBiometricsEnableDialog) as? () -> Void
		perform?()
    }

    func showBiometricsSuccessDialog() {
        addInvocation(.m_showBiometricsSuccessDialog)
		let perform = methodPerformValue(.m_showBiometricsSuccessDialog) as? () -> Void
		perform?()
    }

    func showIsBiometricsRequired(_ isBiometricsRequired: Bool) {
        addInvocation(.m_showIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>.value(`isBiometricsRequired`)))
		let perform = methodPerformValue(.m_showIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>.value(`isBiometricsRequired`))) as? (Bool) -> Void
		perform?(`isBiometricsRequired`)
    }

    func showIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Bool) {
        addInvocation(.m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>.value(`isPinRequiredOnLaunch`)))
		let perform = methodPerformValue(.m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>.value(`isPinRequiredOnLaunch`))) as? (Bool) -> Void
		perform?(`isPinRequiredOnLaunch`)
    }

    func showPinNotAvailableDialog() {
        addInvocation(.m_showPinNotAvailableDialog)
		let perform = methodPerformValue(.m_showPinNotAvailableDialog) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showPinDialogForRegistration
        case m_showPinDialogForBiometrics
        case m_showBiometricsEnableDialog
        case m_showBiometricsSuccessDialog
        case m_showIsBiometricsRequired__isBiometricsRequired(Parameter<Bool>)
        case m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(Parameter<Bool>)
        case m_showPinNotAvailableDialog
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<SettingTopPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showPinDialogForRegistration, .m_showPinDialogForRegistration):
                return true 
            case (.m_showPinDialogForBiometrics, .m_showPinDialogForBiometrics):
                return true 
            case (.m_showBiometricsEnableDialog, .m_showBiometricsEnableDialog):
                return true 
            case (.m_showBiometricsSuccessDialog, .m_showBiometricsSuccessDialog):
                return true 
            case (.m_showIsBiometricsRequired__isBiometricsRequired(let lhsIsbiometricsrequired), .m_showIsBiometricsRequired__isBiometricsRequired(let rhsIsbiometricsrequired)):
                guard Parameter.compare(lhs: lhsIsbiometricsrequired, rhs: rhsIsbiometricsrequired, with: matcher) else { return false } 
                return true 
            case (.m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(let lhsIspinrequiredonlaunch), .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(let rhsIspinrequiredonlaunch)):
                guard Parameter.compare(lhs: lhsIspinrequiredonlaunch, rhs: rhsIspinrequiredonlaunch, with: matcher) else { return false } 
                return true 
            case (.m_showPinNotAvailableDialog, .m_showPinNotAvailableDialog):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<SettingTopPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showPinDialogForRegistration: return 0
            case .m_showPinDialogForBiometrics: return 0
            case .m_showBiometricsEnableDialog: return 0
            case .m_showBiometricsSuccessDialog: return 0
            case let .m_showIsBiometricsRequired__isBiometricsRequired(p0): return p0.intValue
            case let .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(p0): return p0.intValue
            case .m_showPinNotAvailableDialog: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: SettingTopPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showPinDialogForRegistration() -> Verify { return Verify(method: .m_showPinDialogForRegistration)}
        static func showPinDialogForBiometrics() -> Verify { return Verify(method: .m_showPinDialogForBiometrics)}
        static func showBiometricsEnableDialog() -> Verify { return Verify(method: .m_showBiometricsEnableDialog)}
        static func showBiometricsSuccessDialog() -> Verify { return Verify(method: .m_showBiometricsSuccessDialog)}
        static func showIsBiometricsRequired(_ isBiometricsRequired: Parameter<Bool>) -> Verify { return Verify(method: .m_showIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isBiometricsRequired` label")
		static func showIsBiometricsRequired(isBiometricsRequired: Parameter<Bool>) -> Verify { return Verify(method: .m_showIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`))}
        static func showIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Parameter<Bool>) -> Verify { return Verify(method: .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPinRequiredOnLaunch` label")
		static func showIsPinRequiredOnLaunch(isPinRequiredOnLaunch: Parameter<Bool>) -> Verify { return Verify(method: .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`))}
        static func showPinNotAvailableDialog() -> Verify { return Verify(method: .m_showPinNotAvailableDialog)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<SettingTopPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showPinDialogForRegistration(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showPinDialogForRegistration, performs: perform)
        }
        static func showPinDialogForBiometrics(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showPinDialogForBiometrics, performs: perform)
        }
        static func showBiometricsEnableDialog(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showBiometricsEnableDialog, performs: perform)
        }
        static func showBiometricsSuccessDialog(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showBiometricsSuccessDialog, performs: perform)
        }
        static func showIsBiometricsRequired(_ isBiometricsRequired: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isBiometricsRequired` label")
		static func showIsBiometricsRequired(isBiometricsRequired: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showIsBiometricsRequired__isBiometricsRequired(`isBiometricsRequired`), performs: perform)
        }
        static func showIsPinRequiredOnLaunch(_ isPinRequiredOnLaunch: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `isPinRequiredOnLaunch` label")
		static func showIsPinRequiredOnLaunch(isPinRequiredOnLaunch: Parameter<Bool>, perform: @escaping (Bool) -> Void) -> Perform {
            return Perform(method: .m_showIsPinRequiredOnLaunch__isPinRequiredOnLaunch(`isPinRequiredOnLaunch`), performs: perform)
        }
        static func showPinNotAvailableDialog(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showPinNotAvailableDialog, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - SettingTopWireframe
class SettingTopWireframeMock: SettingTopWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "SettingTopWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentNodeSelect() {
        addInvocation(.m_presentNodeSelect)
		let perform = methodPerformValue(.m_presentNodeSelect) as? () -> Void
		perform?()
    }

    func presentSecurityLesson() {
        addInvocation(.m_presentSecurityLesson)
		let perform = methodPerformValue(.m_presentSecurityLesson) as? () -> Void
		perform?()
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentNodeSelect
        case m_presentSecurityLesson
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentNodeSelect, .m_presentNodeSelect):
                return true 
            case (.m_presentSecurityLesson, .m_presentSecurityLesson):
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentNodeSelect: return 0
            case .m_presentSecurityLesson: return 0
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentNodeSelect() -> Verify { return Verify(method: .m_presentNodeSelect)}
        static func presentSecurityLesson() -> Verify { return Verify(method: .m_presentSecurityLesson)}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentNodeSelect(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentNodeSelect, performs: perform)
        }
        static func presentSecurityLesson(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentSecurityLesson, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - TransactionDetailInteractorOutput
class TransactionDetailInteractorOutputMock: TransactionDetailInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func publicKeyFetched(_ publicKey: String?) {
        addInvocation(.m_publicKeyFetched__publicKey(Parameter<String?>.value(`publicKey`)))
		let perform = methodPerformValue(.m_publicKeyFetched__publicKey(Parameter<String?>.value(`publicKey`))) as? (String?) -> Void
		perform?(`publicKey`)
    }

    func publicKeyFetchFailed(_ error: Error) {
        addInvocation(.m_publicKeyFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_publicKeyFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_publicKeyFetched__publicKey(Parameter<String?>)
        case m_publicKeyFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_publicKeyFetched__publicKey(let lhsPublickey), .m_publicKeyFetched__publicKey(let rhsPublickey)):
                guard Parameter.compare(lhs: lhsPublickey, rhs: rhsPublickey, with: matcher) else { return false } 
                return true 
            case (.m_publicKeyFetchFailed__error(let lhsError), .m_publicKeyFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_publicKeyFetched__publicKey(p0): return p0.intValue
            case let .m_publicKeyFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func publicKeyFetched(_ publicKey: Parameter<String?>) -> Verify { return Verify(method: .m_publicKeyFetched__publicKey(`publicKey`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `publicKey` label")
		static func publicKeyFetched(publicKey: Parameter<String?>) -> Verify { return Verify(method: .m_publicKeyFetched__publicKey(`publicKey`))}
        static func publicKeyFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_publicKeyFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func publicKeyFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_publicKeyFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func publicKeyFetched(_ publicKey: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetched__publicKey(`publicKey`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `publicKey` label")
		static func publicKeyFetched(publicKey: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetched__publicKey(`publicKey`), performs: perform)
        }
        static func publicKeyFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func publicKeyFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_publicKeyFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionDetailPresentation
class TransactionDetailPresentationMock: TransactionDetailPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: TransactionDetailView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "TransactionDetailPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (TransactionDetailView)?

    var interactor: TransactionDetailUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "TransactionDetailPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (TransactionDetailUseCase)?

    var router: TransactionDetailWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "TransactionDetailPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (TransactionDetailWireframe)?





    func didClickEncrypted() {
        addInvocation(.m_didClickEncrypted)
		let perform = methodPerformValue(.m_didClickEncrypted) as? () -> Void
		perform?()
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }

    func didRegisterPin(_ pin: String) {
        addInvocation(.m_didRegisterPin__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didRegisterPin__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didValidatePin(_ pin: String) {
        addInvocation(.m_didValidatePin__pin(Parameter<String>.value(`pin`)))
		let perform = methodPerformValue(.m_didValidatePin__pin(Parameter<String>.value(`pin`))) as? (String) -> Void
		perform?(`pin`)
    }

    func didCancelPin() {
        addInvocation(.m_didCancelPin)
		let perform = methodPerformValue(.m_didCancelPin) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickEncrypted
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case m_didRegisterPin__pin(Parameter<String>)
        case m_didValidatePin__pin(Parameter<String>)
        case m_didCancelPin
        case p_view_get
		case p_view_set(Parameter<TransactionDetailView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<TransactionDetailUseCase?>)
        case p_router_get
		case p_router_set(Parameter<TransactionDetailWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickEncrypted, .m_didClickEncrypted):
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.m_didRegisterPin__pin(let lhsPin), .m_didRegisterPin__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didValidatePin__pin(let lhsPin), .m_didValidatePin__pin(let rhsPin)):
                guard Parameter.compare(lhs: lhsPin, rhs: rhsPin, with: matcher) else { return false } 
                return true 
            case (.m_didCancelPin, .m_didCancelPin):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<TransactionDetailView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<TransactionDetailUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<TransactionDetailWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickEncrypted: return 0
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case let .m_didRegisterPin__pin(p0): return p0.intValue
            case let .m_didValidatePin__pin(p0): return p0.intValue
            case .m_didCancelPin: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: TransactionDetailView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: TransactionDetailUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: TransactionDetailWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickEncrypted() -> Verify { return Verify(method: .m_didClickEncrypted)}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static func didRegisterPin(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>) -> Verify { return Verify(method: .m_didRegisterPin__pin(`pin`))}
        static func didValidatePin(_ pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePin__pin(`pin`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePin(pin: Parameter<String>) -> Verify { return Verify(method: .m_didValidatePin__pin(`pin`))}
        static func didCancelPin() -> Verify { return Verify(method: .m_didCancelPin)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<TransactionDetailView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<TransactionDetailUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<TransactionDetailWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickEncrypted(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickEncrypted, performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
        static func didRegisterPin(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didRegisterPin(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didRegisterPin__pin(`pin`), performs: perform)
        }
        static func didValidatePin(_ pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePin__pin(`pin`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `pin` label")
		static func didValidatePin(pin: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_didValidatePin__pin(`pin`), performs: perform)
        }
        static func didCancelPin(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didCancelPin, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionDetailUseCase
class TransactionDetailUseCaseMock: TransactionDetailUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: TransactionDetailInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "TransactionDetailUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (TransactionDetailInteractorOutput)?





    func fetchPublicKey(_ address: String) {
        addInvocation(.m_fetchPublicKey__address(Parameter<String>.value(`address`)))
		let perform = methodPerformValue(.m_fetchPublicKey__address(Parameter<String>.value(`address`))) as? (String) -> Void
		perform?(`address`)
    }


    fileprivate enum MethodType {
        case m_fetchPublicKey__address(Parameter<String>)
        case p_output_get
		case p_output_set(Parameter<TransactionDetailInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchPublicKey__address(let lhsAddress), .m_fetchPublicKey__address(let rhsAddress)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<TransactionDetailInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchPublicKey__address(p0): return p0.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: TransactionDetailInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchPublicKey(_ address: Parameter<String>) -> Verify { return Verify(method: .m_fetchPublicKey__address(`address`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchPublicKey(address: Parameter<String>) -> Verify { return Verify(method: .m_fetchPublicKey__address(`address`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<TransactionDetailInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchPublicKey(_ address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchPublicKey__address(`address`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchPublicKey(address: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_fetchPublicKey__address(`address`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionDetailView
class TransactionDetailViewMock: TransactionDetailView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: TransactionDetailPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "TransactionDetailViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (TransactionDetailPresentation)?





    func showTransaction(_ transaction: TransferTransactionDetail) {
        addInvocation(.m_showTransaction__transaction(Parameter<TransferTransactionDetail>.value(`transaction`)))
		let perform = methodPerformValue(.m_showTransaction__transaction(Parameter<TransferTransactionDetail>.value(`transaction`))) as? (TransferTransactionDetail) -> Void
		perform?(`transaction`)
    }

    func showMessage(_ message: String) {
        addInvocation(.m_showMessage__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showMessage__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showEncryptedButton() {
        addInvocation(.m_showEncryptedButton)
		let perform = methodPerformValue(.m_showEncryptedButton) as? () -> Void
		perform?()
    }

    func showPublicKeyLoading() {
        addInvocation(.m_showPublicKeyLoading)
		let perform = methodPerformValue(.m_showPublicKeyLoading) as? () -> Void
		perform?()
    }

    func hidePublicKeyLoading() {
        addInvocation(.m_hidePublicKeyLoading)
		let perform = methodPerformValue(.m_hidePublicKeyLoading) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showPinDialog(presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (PinDialogMixinPresentation) -> Void
		perform?(`presenter`)
    }

    func showPinDialog(forRegistration: Bool,presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (Bool, PinDialogMixinPresentation) -> Void
		perform?(`forRegistration`, `presenter`)
    }

    func showPinDialog(forRegistration: Bool, cancelable: Bool, presenter: PinDialogMixinPresentation) {
        addInvocation(.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<PinDialogMixinPresentation>.value(`presenter`)))
		let perform = methodPerformValue(.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>.value(`forRegistration`), Parameter<Bool>.value(`cancelable`), Parameter<PinDialogMixinPresentation>.value(`presenter`))) as? (Bool, Bool, PinDialogMixinPresentation) -> Void
		perform?(`forRegistration`, `cancelable`, `presenter`)
    }


    fileprivate enum MethodType {
        case m_showTransaction__transaction(Parameter<TransferTransactionDetail>)
        case m_showMessage__message(Parameter<String>)
        case m_showEncryptedButton
        case m_showPublicKeyLoading
        case m_hidePublicKeyLoading
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case m_showPinDialog__presenter_presenter(Parameter<PinDialogMixinPresentation>)
        case m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(Parameter<Bool>, Parameter<PinDialogMixinPresentation>)
        case m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(Parameter<Bool>, Parameter<Bool>, Parameter<PinDialogMixinPresentation>)
        case p_presenter_get
		case p_presenter_set(Parameter<TransactionDetailPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showTransaction__transaction(let lhsTransaction), .m_showTransaction__transaction(let rhsTransaction)):
                guard Parameter.compare(lhs: lhsTransaction, rhs: rhsTransaction, with: matcher) else { return false } 
                return true 
            case (.m_showMessage__message(let lhsMessage), .m_showMessage__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showEncryptedButton, .m_showEncryptedButton):
                return true 
            case (.m_showPublicKeyLoading, .m_showPublicKeyLoading):
                return true 
            case (.m_hidePublicKeyLoading, .m_hidePublicKeyLoading):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__presenter_presenter(let lhsPresenter), .m_showPinDialog__presenter_presenter(let rhsPresenter)):
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(let lhsForregistration, let lhsPresenter), .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(let rhsForregistration, let rhsPresenter)):
                guard Parameter.compare(lhs: lhsForregistration, rhs: rhsForregistration, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(let lhsForregistration, let lhsCancelable, let lhsPresenter), .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(let rhsForregistration, let rhsCancelable, let rhsPresenter)):
                guard Parameter.compare(lhs: lhsForregistration, rhs: rhsForregistration, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsCancelable, rhs: rhsCancelable, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsPresenter, rhs: rhsPresenter, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<TransactionDetailPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showTransaction__transaction(p0): return p0.intValue
            case let .m_showMessage__message(p0): return p0.intValue
            case .m_showEncryptedButton: return 0
            case .m_showPublicKeyLoading: return 0
            case .m_hidePublicKeyLoading: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case let .m_showPinDialog__presenter_presenter(p0): return p0.intValue
            case let .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(p0, p1): return p0.intValue + p1.intValue
            case let .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: TransactionDetailPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showTransaction(_ transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_showTransaction__transaction(`transaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func showTransaction(transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_showTransaction__transaction(`transaction`))}
        static func showMessage(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>) -> Verify { return Verify(method: .m_showMessage__message(`message`))}
        static func showEncryptedButton() -> Verify { return Verify(method: .m_showEncryptedButton)}
        static func showPublicKeyLoading() -> Verify { return Verify(method: .m_showPublicKeyLoading)}
        static func hidePublicKeyLoading() -> Verify { return Verify(method: .m_hidePublicKeyLoading)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static func showPinDialog(presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__presenter_presenter(`presenter`))}
        static func showPinDialog(forRegistration: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(`forRegistration`, `presenter`))}
        static func showPinDialog(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>) -> Verify { return Verify(method: .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(`forRegistration`, `cancelable`, `presenter`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<TransactionDetailPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showTransaction(_ transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_showTransaction__transaction(`transaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func showTransaction(transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_showTransaction__transaction(`transaction`), performs: perform)
        }
        static func showMessage(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showMessage(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showMessage__message(`message`), performs: perform)
        }
        static func showEncryptedButton(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showEncryptedButton, performs: perform)
        }
        static func showPublicKeyLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showPublicKeyLoading, performs: perform)
        }
        static func hidePublicKeyLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hidePublicKeyLoading, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        static func showPinDialog(presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__presenter_presenter(`presenter`), performs: perform)
        }
        static func showPinDialog(forRegistration: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (Bool, PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__forRegistration_forRegistrationpresenter_presenter(`forRegistration`, `presenter`), performs: perform)
        }
        static func showPinDialog(forRegistration: Parameter<Bool>, cancelable: Parameter<Bool>, presenter: Parameter<PinDialogMixinPresentation>, perform: @escaping (Bool, Bool, PinDialogMixinPresentation) -> Void) -> Perform {
            return Perform(method: .m_showPinDialog__forRegistration_forRegistrationcancelable_cancelablepresenter_presenter(`forRegistration`, `cancelable`, `presenter`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionDetailWireframe
class TransactionDetailWireframeMock: TransactionDetailWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "TransactionDetailWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule(_ transaction: TransferTransactionDetail) -> UIViewController {
        addInvocation(.sm_assembleModule__transaction(Parameter<TransferTransactionDetail>.value(`transaction`)))
		let perform = methodPerformValue(.sm_assembleModule__transaction(Parameter<TransferTransactionDetail>.value(`transaction`))) as? (TransferTransactionDetail) -> Void
		perform?(`transaction`)
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule__transaction(Parameter<TransferTransactionDetail>.value(`transaction`))).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(_ transaction: TransferTransactionDetail). Use given")
		}
		return __value
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule__transaction(Parameter<TransferTransactionDetail>)

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule__transaction(let lhsTransaction), .sm_assembleModule__transaction(let rhsTransaction)):
                guard Parameter.compare(lhs: lhsTransaction, rhs: rhsTransaction, with: matcher) else { return false } 
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case let .sm_assembleModule__transaction(p0): return p0.intValue
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(_ transaction: Parameter<TransferTransactionDetail>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__transaction(`transaction`), products: willReturn.map({ Product.return($0) }))
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func assembleModule(transaction: Parameter<TransferTransactionDetail>, willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule__transaction(`transaction`), products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(_ transaction: Parameter<TransferTransactionDetail>, willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule__transaction(`transaction`), products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule(_ transaction: Parameter<TransferTransactionDetail>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__transaction(`transaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func assembleModule(transaction: Parameter<TransferTransactionDetail>) -> StaticVerify { return StaticVerify(method: .sm_assembleModule__transaction(`transaction`))}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(_ transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__transaction(`transaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func assembleModule(transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule__transaction(`transaction`), performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - TransactionListInteractorOutput
class TransactionListInteractorOutputMock: TransactionListInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func transferTransactionDetailFetched(_ transactions: [TransferTransactionDetail]) {
        addInvocation(.m_transferTransactionDetailFetched__transactions(Parameter<[TransferTransactionDetail]>.value(`transactions`)))
		let perform = methodPerformValue(.m_transferTransactionDetailFetched__transactions(Parameter<[TransferTransactionDetail]>.value(`transactions`))) as? ([TransferTransactionDetail]) -> Void
		perform?(`transactions`)
    }

    func transferTransactionDetailFetchFailed(_ error: Error) {
        addInvocation(.m_transferTransactionDetailFetchFailed__error(Parameter<Error>.value(`error`)))
		let perform = methodPerformValue(.m_transferTransactionDetailFetchFailed__error(Parameter<Error>.value(`error`))) as? (Error) -> Void
		perform?(`error`)
    }


    fileprivate enum MethodType {
        case m_transferTransactionDetailFetched__transactions(Parameter<[TransferTransactionDetail]>)
        case m_transferTransactionDetailFetchFailed__error(Parameter<Error>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_transferTransactionDetailFetched__transactions(let lhsTransactions), .m_transferTransactionDetailFetched__transactions(let rhsTransactions)):
                guard Parameter.compare(lhs: lhsTransactions, rhs: rhsTransactions, with: matcher) else { return false } 
                return true 
            case (.m_transferTransactionDetailFetchFailed__error(let lhsError), .m_transferTransactionDetailFetchFailed__error(let rhsError)):
                guard Parameter.compare(lhs: lhsError, rhs: rhsError, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_transferTransactionDetailFetched__transactions(p0): return p0.intValue
            case let .m_transferTransactionDetailFetchFailed__error(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func transferTransactionDetailFetched(_ transactions: Parameter<[TransferTransactionDetail]>) -> Verify { return Verify(method: .m_transferTransactionDetailFetched__transactions(`transactions`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transactions` label")
		static func transferTransactionDetailFetched(transactions: Parameter<[TransferTransactionDetail]>) -> Verify { return Verify(method: .m_transferTransactionDetailFetched__transactions(`transactions`))}
        static func transferTransactionDetailFetchFailed(_ error: Parameter<Error>) -> Verify { return Verify(method: .m_transferTransactionDetailFetchFailed__error(`error`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func transferTransactionDetailFetchFailed(error: Parameter<Error>) -> Verify { return Verify(method: .m_transferTransactionDetailFetchFailed__error(`error`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func transferTransactionDetailFetched(_ transactions: Parameter<[TransferTransactionDetail]>, perform: @escaping ([TransferTransactionDetail]) -> Void) -> Perform {
            return Perform(method: .m_transferTransactionDetailFetched__transactions(`transactions`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transactions` label")
		static func transferTransactionDetailFetched(transactions: Parameter<[TransferTransactionDetail]>, perform: @escaping ([TransferTransactionDetail]) -> Void) -> Perform {
            return Perform(method: .m_transferTransactionDetailFetched__transactions(`transactions`), performs: perform)
        }
        static func transferTransactionDetailFetchFailed(_ error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_transferTransactionDetailFetchFailed__error(`error`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `error` label")
		static func transferTransactionDetailFetchFailed(error: Parameter<Error>, perform: @escaping (Error) -> Void) -> Perform {
            return Perform(method: .m_transferTransactionDetailFetchFailed__error(`error`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionListPresentation
class TransactionListPresentationMock: TransactionListPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: TransactionListView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "TransactionListPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (TransactionListView)?

    var interactor: TransactionListUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "TransactionListPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (TransactionListUseCase)?

    var router: TransactionListWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "TransactionListPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (TransactionListWireframe)?





    func didRefresh() {
        addInvocation(.m_didRefresh)
		let perform = methodPerformValue(.m_didRefresh) as? () -> Void
		perform?()
    }

    func didReachLastRow() {
        addInvocation(.m_didReachLastRow)
		let perform = methodPerformValue(.m_didReachLastRow) as? () -> Void
		perform?()
    }

    func didClickTransaction(_ transaction: TransferTransactionDetail) {
        addInvocation(.m_didClickTransaction__transaction(Parameter<TransferTransactionDetail>.value(`transaction`)))
		let perform = methodPerformValue(.m_didClickTransaction__transaction(Parameter<TransferTransactionDetail>.value(`transaction`))) as? (TransferTransactionDetail) -> Void
		perform?(`transaction`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didRefresh
        case m_didReachLastRow
        case m_didClickTransaction__transaction(Parameter<TransferTransactionDetail>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<TransactionListView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<TransactionListUseCase?>)
        case p_router_get
		case p_router_set(Parameter<TransactionListWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didRefresh, .m_didRefresh):
                return true 
            case (.m_didReachLastRow, .m_didReachLastRow):
                return true 
            case (.m_didClickTransaction__transaction(let lhsTransaction), .m_didClickTransaction__transaction(let rhsTransaction)):
                guard Parameter.compare(lhs: lhsTransaction, rhs: rhsTransaction, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<TransactionListView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<TransactionListUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<TransactionListWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didRefresh: return 0
            case .m_didReachLastRow: return 0
            case let .m_didClickTransaction__transaction(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: TransactionListView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: TransactionListUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: TransactionListWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didRefresh() -> Verify { return Verify(method: .m_didRefresh)}
        static func didReachLastRow() -> Verify { return Verify(method: .m_didReachLastRow)}
        static func didClickTransaction(_ transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_didClickTransaction__transaction(`transaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func didClickTransaction(transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_didClickTransaction__transaction(`transaction`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<TransactionListView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<TransactionListUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<TransactionListWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didRefresh(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didRefresh, performs: perform)
        }
        static func didReachLastRow(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didReachLastRow, performs: perform)
        }
        static func didClickTransaction(_ transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_didClickTransaction__transaction(`transaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func didClickTransaction(transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_didClickTransaction__transaction(`transaction`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionListUseCase
class TransactionListUseCaseMock: TransactionListUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: TransactionListInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "TransactionListUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (TransactionListInteractorOutput)?





    func fetchTransferTransactionDetail(_ address: String, withUnconfirmed: Bool, id: Int?) {
        addInvocation(.m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(Parameter<String>.value(`address`), Parameter<Bool>.value(`withUnconfirmed`), Parameter<Int?>.value(`id`)))
		let perform = methodPerformValue(.m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(Parameter<String>.value(`address`), Parameter<Bool>.value(`withUnconfirmed`), Parameter<Int?>.value(`id`))) as? (String, Bool, Int?) -> Void
		perform?(`address`, `withUnconfirmed`, `id`)
    }


    fileprivate enum MethodType {
        case m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(Parameter<String>, Parameter<Bool>, Parameter<Int?>)
        case p_output_get
		case p_output_set(Parameter<TransactionListInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(let lhsAddress, let lhsWithunconfirmed, let lhsId), .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(let rhsAddress, let rhsWithunconfirmed, let rhsId)):
                guard Parameter.compare(lhs: lhsAddress, rhs: rhsAddress, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsWithunconfirmed, rhs: rhsWithunconfirmed, with: matcher) else { return false } 
                guard Parameter.compare(lhs: lhsId, rhs: rhsId, with: matcher) else { return false } 
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<TransactionListInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(p0, p1, p2): return p0.intValue + p1.intValue + p2.intValue
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: TransactionListInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func fetchTransferTransactionDetail(_ address: Parameter<String>, withUnconfirmed: Parameter<Bool>, id: Parameter<Int?>) -> Verify { return Verify(method: .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(`address`, `withUnconfirmed`, `id`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchTransferTransactionDetail(address: Parameter<String>, withUnconfirmed: Parameter<Bool>, id: Parameter<Int?>) -> Verify { return Verify(method: .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(`address`, `withUnconfirmed`, `id`))}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<TransactionListInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func fetchTransferTransactionDetail(_ address: Parameter<String>, withUnconfirmed: Parameter<Bool>, id: Parameter<Int?>, perform: @escaping (String, Bool, Int?) -> Void) -> Perform {
            return Perform(method: .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(`address`, `withUnconfirmed`, `id`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `address` label")
		static func fetchTransferTransactionDetail(address: Parameter<String>, withUnconfirmed: Parameter<Bool>, id: Parameter<Int?>, perform: @escaping (String, Bool, Int?) -> Void) -> Perform {
            return Perform(method: .m_fetchTransferTransactionDetail__addresswithUnconfirmed_withUnconfirmedid_id(`address`, `withUnconfirmed`, `id`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionListView
class TransactionListViewMock: TransactionListView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: TransactionListPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "TransactionListViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (TransactionListPresentation)?





    func showLoadingTop() {
        addInvocation(.m_showLoadingTop)
		let perform = methodPerformValue(.m_showLoadingTop) as? () -> Void
		perform?()
    }

    func showLoadingBottom() {
        addInvocation(.m_showLoadingBottom)
		let perform = methodPerformValue(.m_showLoadingBottom) as? () -> Void
		perform?()
    }

    func hideLoading() {
        addInvocation(.m_hideLoading)
		let perform = methodPerformValue(.m_hideLoading) as? () -> Void
		perform?()
    }

    func showEmpty() {
        addInvocation(.m_showEmpty)
		let perform = methodPerformValue(.m_showEmpty) as? () -> Void
		perform?()
    }

    func showTransactions(_ transactions: [[TransferTransactionDetail]]) {
        addInvocation(.m_showTransactions__transactions(Parameter<[[TransferTransactionDetail]]>.value(`transactions`)))
		let perform = methodPerformValue(.m_showTransactions__transactions(Parameter<[[TransferTransactionDetail]]>.value(`transactions`))) as? ([[TransferTransactionDetail]]) -> Void
		perform?(`transactions`)
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showLoadingTop
        case m_showLoadingBottom
        case m_hideLoading
        case m_showEmpty
        case m_showTransactions__transactions(Parameter<[[TransferTransactionDetail]]>)
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<TransactionListPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showLoadingTop, .m_showLoadingTop):
                return true 
            case (.m_showLoadingBottom, .m_showLoadingBottom):
                return true 
            case (.m_hideLoading, .m_hideLoading):
                return true 
            case (.m_showEmpty, .m_showEmpty):
                return true 
            case (.m_showTransactions__transactions(let lhsTransactions), .m_showTransactions__transactions(let rhsTransactions)):
                guard Parameter.compare(lhs: lhsTransactions, rhs: rhsTransactions, with: matcher) else { return false } 
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<TransactionListPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_showLoadingTop: return 0
            case .m_showLoadingBottom: return 0
            case .m_hideLoading: return 0
            case .m_showEmpty: return 0
            case let .m_showTransactions__transactions(p0): return p0.intValue
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: TransactionListPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showLoadingTop() -> Verify { return Verify(method: .m_showLoadingTop)}
        static func showLoadingBottom() -> Verify { return Verify(method: .m_showLoadingBottom)}
        static func hideLoading() -> Verify { return Verify(method: .m_hideLoading)}
        static func showEmpty() -> Verify { return Verify(method: .m_showEmpty)}
        static func showTransactions(_ transactions: Parameter<[[TransferTransactionDetail]]>) -> Verify { return Verify(method: .m_showTransactions__transactions(`transactions`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transactions` label")
		static func showTransactions(transactions: Parameter<[[TransferTransactionDetail]]>) -> Verify { return Verify(method: .m_showTransactions__transactions(`transactions`))}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<TransactionListPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showLoadingTop(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoadingTop, performs: perform)
        }
        static func showLoadingBottom(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showLoadingBottom, performs: perform)
        }
        static func hideLoading(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_hideLoading, performs: perform)
        }
        static func showEmpty(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showEmpty, performs: perform)
        }
        static func showTransactions(_ transactions: Parameter<[[TransferTransactionDetail]]>, perform: @escaping ([[TransferTransactionDetail]]) -> Void) -> Perform {
            return Perform(method: .m_showTransactions__transactions(`transactions`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transactions` label")
		static func showTransactions(transactions: Parameter<[[TransferTransactionDetail]]>, perform: @escaping ([[TransferTransactionDetail]]) -> Void) -> Perform {
            return Perform(method: .m_showTransactions__transactions(`transactions`), performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - TransactionListWireframe
class TransactionListWireframeMock: TransactionListWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "TransactionListWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentTransactionDetail(_ transaction: TransferTransactionDetail) {
        addInvocation(.m_presentTransactionDetail__transaction(Parameter<TransferTransactionDetail>.value(`transaction`)))
		let perform = methodPerformValue(.m_presentTransactionDetail__transaction(Parameter<TransferTransactionDetail>.value(`transaction`))) as? (TransferTransactionDetail) -> Void
		perform?(`transaction`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentTransactionDetail__transaction(Parameter<TransferTransactionDetail>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentTransactionDetail__transaction(let lhsTransaction), .m_presentTransactionDetail__transaction(let rhsTransaction)):
                guard Parameter.compare(lhs: lhsTransaction, rhs: rhsTransaction, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_presentTransactionDetail__transaction(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentTransactionDetail(_ transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_presentTransactionDetail__transaction(`transaction`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func presentTransactionDetail(transaction: Parameter<TransferTransactionDetail>) -> Verify { return Verify(method: .m_presentTransactionDetail__transaction(`transaction`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentTransactionDetail(_ transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_presentTransactionDetail__transaction(`transaction`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `transaction` label")
		static func presentTransactionDetail(transaction: Parameter<TransferTransactionDetail>, perform: @escaping (TransferTransactionDetail) -> Void) -> Perform {
            return Perform(method: .m_presentTransactionDetail__transaction(`transaction`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

// MARK: - WalletSelectInteractorOutput
class WalletSelectInteractorOutputMock: WalletSelectInteractorOutput, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }





    func activeIdFetched(_ id: String?) {
        addInvocation(.m_activeIdFetched__id(Parameter<String?>.value(`id`)))
		let perform = methodPerformValue(.m_activeIdFetched__id(Parameter<String?>.value(`id`))) as? (String?) -> Void
		perform?(`id`)
    }

    func walletsFetched(_ wallets: [Wallet]) {
        addInvocation(.m_walletsFetched__wallets(Parameter<[Wallet]>.value(`wallets`)))
		let perform = methodPerformValue(.m_walletsFetched__wallets(Parameter<[Wallet]>.value(`wallets`))) as? ([Wallet]) -> Void
		perform?(`wallets`)
    }


    fileprivate enum MethodType {
        case m_activeIdFetched__id(Parameter<String?>)
        case m_walletsFetched__wallets(Parameter<[Wallet]>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_activeIdFetched__id(let lhsId), .m_activeIdFetched__id(let rhsId)):
                guard Parameter.compare(lhs: lhsId, rhs: rhsId, with: matcher) else { return false } 
                return true 
            case (.m_walletsFetched__wallets(let lhsWallets), .m_walletsFetched__wallets(let rhsWallets)):
                guard Parameter.compare(lhs: lhsWallets, rhs: rhsWallets, with: matcher) else { return false } 
                return true 
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_activeIdFetched__id(p0): return p0.intValue
            case let .m_walletsFetched__wallets(p0): return p0.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


    }

    struct Verify {
        fileprivate var method: MethodType

        static func activeIdFetched(_ id: Parameter<String?>) -> Verify { return Verify(method: .m_activeIdFetched__id(`id`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `id` label")
		static func activeIdFetched(id: Parameter<String?>) -> Verify { return Verify(method: .m_activeIdFetched__id(`id`))}
        static func walletsFetched(_ wallets: Parameter<[Wallet]>) -> Verify { return Verify(method: .m_walletsFetched__wallets(`wallets`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallets` label")
		static func walletsFetched(wallets: Parameter<[Wallet]>) -> Verify { return Verify(method: .m_walletsFetched__wallets(`wallets`))}
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func activeIdFetched(_ id: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_activeIdFetched__id(`id`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `id` label")
		static func activeIdFetched(id: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_activeIdFetched__id(`id`), performs: perform)
        }
        static func walletsFetched(_ wallets: Parameter<[Wallet]>, perform: @escaping ([Wallet]) -> Void) -> Perform {
            return Perform(method: .m_walletsFetched__wallets(`wallets`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallets` label")
		static func walletsFetched(wallets: Parameter<[Wallet]>, perform: @escaping ([Wallet]) -> Void) -> Perform {
            return Perform(method: .m_walletsFetched__wallets(`wallets`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - WalletSelectPresentation
class WalletSelectPresentationMock: WalletSelectPresentation, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var view: WalletSelectView? {
		get {	invocations.append(.p_view_get); return __p_view ?? optionalGivenGetterValue(.p_view_get, "WalletSelectPresentationMock - stub value for view was not defined") }
		set {	invocations.append(.p_view_set(.value(newValue))); __p_view = newValue }
	}
	private var __p_view: (WalletSelectView)?

    var interactor: WalletSelectUseCase! {
		get {	invocations.append(.p_interactor_get); return __p_interactor ?? optionalGivenGetterValue(.p_interactor_get, "WalletSelectPresentationMock - stub value for interactor was not defined") }
		set {	invocations.append(.p_interactor_set(.value(newValue))); __p_interactor = newValue }
	}
	private var __p_interactor: (WalletSelectUseCase)?

    var router: WalletSelectWireframe! {
		get {	invocations.append(.p_router_get); return __p_router ?? optionalGivenGetterValue(.p_router_get, "WalletSelectPresentationMock - stub value for router was not defined") }
		set {	invocations.append(.p_router_set(.value(newValue))); __p_router = newValue }
	}
	private var __p_router: (WalletSelectWireframe)?





    func didClickCreate() {
        addInvocation(.m_didClickCreate)
		let perform = methodPerformValue(.m_didClickCreate) as? () -> Void
		perform?()
    }

    func didSelectWallet(_ wallet: Wallet) {
        addInvocation(.m_didSelectWallet__wallet(Parameter<Wallet>.value(`wallet`)))
		let perform = methodPerformValue(.m_didSelectWallet__wallet(Parameter<Wallet>.value(`wallet`))) as? (Wallet) -> Void
		perform?(`wallet`)
    }

    func didClickSetting(_ wallet: Wallet) {
        addInvocation(.m_didClickSetting__wallet(Parameter<Wallet>.value(`wallet`)))
		let perform = methodPerformValue(.m_didClickSetting__wallet(Parameter<Wallet>.value(`wallet`))) as? (Wallet) -> Void
		perform?(`wallet`)
    }

    func viewDidLoad() {
        addInvocation(.m_viewDidLoad)
		let perform = methodPerformValue(.m_viewDidLoad) as? () -> Void
		perform?()
    }

    func viewWillAppear() {
        addInvocation(.m_viewWillAppear)
		let perform = methodPerformValue(.m_viewWillAppear) as? () -> Void
		perform?()
    }

    func viewDidAppear() {
        addInvocation(.m_viewDidAppear)
		let perform = methodPerformValue(.m_viewDidAppear) as? () -> Void
		perform?()
    }

    func viewWillDisappear() {
        addInvocation(.m_viewWillDisappear)
		let perform = methodPerformValue(.m_viewWillDisappear) as? () -> Void
		perform?()
    }

    func viewDidDisappear() {
        addInvocation(.m_viewDidDisappear)
		let perform = methodPerformValue(.m_viewDidDisappear) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_didClickCreate
        case m_didSelectWallet__wallet(Parameter<Wallet>)
        case m_didClickSetting__wallet(Parameter<Wallet>)
        case m_viewDidLoad
        case m_viewWillAppear
        case m_viewDidAppear
        case m_viewWillDisappear
        case m_viewDidDisappear
        case p_view_get
		case p_view_set(Parameter<WalletSelectView?>)
        case p_interactor_get
		case p_interactor_set(Parameter<WalletSelectUseCase?>)
        case p_router_get
		case p_router_set(Parameter<WalletSelectWireframe?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_didClickCreate, .m_didClickCreate):
                return true 
            case (.m_didSelectWallet__wallet(let lhsWallet), .m_didSelectWallet__wallet(let rhsWallet)):
                guard Parameter.compare(lhs: lhsWallet, rhs: rhsWallet, with: matcher) else { return false } 
                return true 
            case (.m_didClickSetting__wallet(let lhsWallet), .m_didClickSetting__wallet(let rhsWallet)):
                guard Parameter.compare(lhs: lhsWallet, rhs: rhsWallet, with: matcher) else { return false } 
                return true 
            case (.m_viewDidLoad, .m_viewDidLoad):
                return true 
            case (.m_viewWillAppear, .m_viewWillAppear):
                return true 
            case (.m_viewDidAppear, .m_viewDidAppear):
                return true 
            case (.m_viewWillDisappear, .m_viewWillDisappear):
                return true 
            case (.m_viewDidDisappear, .m_viewDidDisappear):
                return true 
            case (.p_view_get,.p_view_get): return true
			case (.p_view_set(let left),.p_view_set(let right)): return Parameter<WalletSelectView?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_interactor_get,.p_interactor_get): return true
			case (.p_interactor_set(let left),.p_interactor_set(let right)): return Parameter<WalletSelectUseCase?>.compare(lhs: left, rhs: right, with: matcher)
            case (.p_router_get,.p_router_get): return true
			case (.p_router_set(let left),.p_router_set(let right)): return Parameter<WalletSelectWireframe?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_didClickCreate: return 0
            case let .m_didSelectWallet__wallet(p0): return p0.intValue
            case let .m_didClickSetting__wallet(p0): return p0.intValue
            case .m_viewDidLoad: return 0
            case .m_viewWillAppear: return 0
            case .m_viewDidAppear: return 0
            case .m_viewWillDisappear: return 0
            case .m_viewDidDisappear: return 0
            case .p_view_get: return 0
			case .p_view_set(let newValue): return newValue.intValue
            case .p_interactor_get: return 0
			case .p_interactor_set(let newValue): return newValue.intValue
            case .p_router_get: return 0
			case .p_router_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func view(getter defaultValue: WalletSelectView?...) -> PropertyStub {
            return Given(method: .p_view_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func interactor(getter defaultValue: WalletSelectUseCase?...) -> PropertyStub {
            return Given(method: .p_interactor_get, products: defaultValue.map({ Product.return($0) }))
        }
        static func router(getter defaultValue: WalletSelectWireframe?...) -> PropertyStub {
            return Given(method: .p_router_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func didClickCreate() -> Verify { return Verify(method: .m_didClickCreate)}
        static func didSelectWallet(_ wallet: Parameter<Wallet>) -> Verify { return Verify(method: .m_didSelectWallet__wallet(`wallet`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallet` label")
		static func didSelectWallet(wallet: Parameter<Wallet>) -> Verify { return Verify(method: .m_didSelectWallet__wallet(`wallet`))}
        static func didClickSetting(_ wallet: Parameter<Wallet>) -> Verify { return Verify(method: .m_didClickSetting__wallet(`wallet`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallet` label")
		static func didClickSetting(wallet: Parameter<Wallet>) -> Verify { return Verify(method: .m_didClickSetting__wallet(`wallet`))}
        static func viewDidLoad() -> Verify { return Verify(method: .m_viewDidLoad)}
        static func viewWillAppear() -> Verify { return Verify(method: .m_viewWillAppear)}
        static func viewDidAppear() -> Verify { return Verify(method: .m_viewDidAppear)}
        static func viewWillDisappear() -> Verify { return Verify(method: .m_viewWillDisappear)}
        static func viewDidDisappear() -> Verify { return Verify(method: .m_viewDidDisappear)}
        static var view: Verify { return Verify(method: .p_view_get) }
		static func view(set newValue: Parameter<WalletSelectView?>) -> Verify { return Verify(method: .p_view_set(newValue)) }
        static var interactor: Verify { return Verify(method: .p_interactor_get) }
		static func interactor(set newValue: Parameter<WalletSelectUseCase?>) -> Verify { return Verify(method: .p_interactor_set(newValue)) }
        static var router: Verify { return Verify(method: .p_router_get) }
		static func router(set newValue: Parameter<WalletSelectWireframe?>) -> Verify { return Verify(method: .p_router_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func didClickCreate(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_didClickCreate, performs: perform)
        }
        static func didSelectWallet(_ wallet: Parameter<Wallet>, perform: @escaping (Wallet) -> Void) -> Perform {
            return Perform(method: .m_didSelectWallet__wallet(`wallet`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallet` label")
		static func didSelectWallet(wallet: Parameter<Wallet>, perform: @escaping (Wallet) -> Void) -> Perform {
            return Perform(method: .m_didSelectWallet__wallet(`wallet`), performs: perform)
        }
        static func didClickSetting(_ wallet: Parameter<Wallet>, perform: @escaping (Wallet) -> Void) -> Perform {
            return Perform(method: .m_didClickSetting__wallet(`wallet`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallet` label")
		static func didClickSetting(wallet: Parameter<Wallet>, perform: @escaping (Wallet) -> Void) -> Perform {
            return Perform(method: .m_didClickSetting__wallet(`wallet`), performs: perform)
        }
        static func viewDidLoad(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidLoad, performs: perform)
        }
        static func viewWillAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillAppear, performs: perform)
        }
        static func viewDidAppear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidAppear, performs: perform)
        }
        static func viewWillDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewWillDisappear, performs: perform)
        }
        static func viewDidDisappear(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_viewDidDisappear, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - WalletSelectUseCase
class WalletSelectUseCaseMock: WalletSelectUseCase, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var output: WalletSelectInteractorOutput! {
		get {	invocations.append(.p_output_get); return __p_output ?? optionalGivenGetterValue(.p_output_get, "WalletSelectUseCaseMock - stub value for output was not defined") }
		set {	invocations.append(.p_output_set(.value(newValue))); __p_output = newValue }
	}
	private var __p_output: (WalletSelectInteractorOutput)?





    func activateWallet(_ id: String) {
        addInvocation(.m_activateWallet__id(Parameter<String>.value(`id`)))
		let perform = methodPerformValue(.m_activateWallet__id(Parameter<String>.value(`id`))) as? (String) -> Void
		perform?(`id`)
    }

    func fetchActiveId() {
        addInvocation(.m_fetchActiveId)
		let perform = methodPerformValue(.m_fetchActiveId) as? () -> Void
		perform?()
    }

    func fetchWallets() {
        addInvocation(.m_fetchWallets)
		let perform = methodPerformValue(.m_fetchWallets) as? () -> Void
		perform?()
    }


    fileprivate enum MethodType {
        case m_activateWallet__id(Parameter<String>)
        case m_fetchActiveId
        case m_fetchWallets
        case p_output_get
		case p_output_set(Parameter<WalletSelectInteractorOutput?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_activateWallet__id(let lhsId), .m_activateWallet__id(let rhsId)):
                guard Parameter.compare(lhs: lhsId, rhs: rhsId, with: matcher) else { return false } 
                return true 
            case (.m_fetchActiveId, .m_fetchActiveId):
                return true 
            case (.m_fetchWallets, .m_fetchWallets):
                return true 
            case (.p_output_get,.p_output_get): return true
			case (.p_output_set(let left),.p_output_set(let right)): return Parameter<WalletSelectInteractorOutput?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_activateWallet__id(p0): return p0.intValue
            case .m_fetchActiveId: return 0
            case .m_fetchWallets: return 0
            case .p_output_get: return 0
			case .p_output_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func output(getter defaultValue: WalletSelectInteractorOutput?...) -> PropertyStub {
            return Given(method: .p_output_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func activateWallet(_ id: Parameter<String>) -> Verify { return Verify(method: .m_activateWallet__id(`id`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `id` label")
		static func activateWallet(id: Parameter<String>) -> Verify { return Verify(method: .m_activateWallet__id(`id`))}
        static func fetchActiveId() -> Verify { return Verify(method: .m_fetchActiveId)}
        static func fetchWallets() -> Verify { return Verify(method: .m_fetchWallets)}
        static var output: Verify { return Verify(method: .p_output_get) }
		static func output(set newValue: Parameter<WalletSelectInteractorOutput?>) -> Verify { return Verify(method: .p_output_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func activateWallet(_ id: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_activateWallet__id(`id`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `id` label")
		static func activateWallet(id: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_activateWallet__id(`id`), performs: perform)
        }
        static func fetchActiveId(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_fetchActiveId, performs: perform)
        }
        static func fetchWallets(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_fetchWallets, performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - WalletSelectView
class WalletSelectViewMock: WalletSelectView, Mock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }

    var presenter: WalletSelectPresentation! {
		get {	invocations.append(.p_presenter_get); return __p_presenter ?? optionalGivenGetterValue(.p_presenter_get, "WalletSelectViewMock - stub value for presenter was not defined") }
		set {	invocations.append(.p_presenter_set(.value(newValue))); __p_presenter = newValue }
	}
	private var __p_presenter: (WalletSelectPresentation)?





    func showActiveId(_ activeId: String?) {
        addInvocation(.m_showActiveId__activeId(Parameter<String?>.value(`activeId`)))
		let perform = methodPerformValue(.m_showActiveId__activeId(Parameter<String?>.value(`activeId`))) as? (String?) -> Void
		perform?(`activeId`)
    }

    func showWallets(_ wallets: [Wallet]) {
        addInvocation(.m_showWallets__wallets(Parameter<[Wallet]>.value(`wallets`)))
		let perform = methodPerformValue(.m_showWallets__wallets(Parameter<[Wallet]>.value(`wallets`))) as? ([Wallet]) -> Void
		perform?(`wallets`)
    }

    func showWalletEmpty() {
        addInvocation(.m_showWalletEmpty)
		let perform = methodPerformValue(.m_showWalletEmpty) as? () -> Void
		perform?()
    }

    func showInfo(_ message: String) {
        addInvocation(.m_showInfo__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showInfo__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }

    func showError(_ message: String) {
        addInvocation(.m_showError__message(Parameter<String>.value(`message`)))
		let perform = methodPerformValue(.m_showError__message(Parameter<String>.value(`message`))) as? (String) -> Void
		perform?(`message`)
    }


    fileprivate enum MethodType {
        case m_showActiveId__activeId(Parameter<String?>)
        case m_showWallets__wallets(Parameter<[Wallet]>)
        case m_showWalletEmpty
        case m_showInfo__message(Parameter<String>)
        case m_showError__message(Parameter<String>)
        case p_presenter_get
		case p_presenter_set(Parameter<WalletSelectPresentation?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_showActiveId__activeId(let lhsActiveid), .m_showActiveId__activeId(let rhsActiveid)):
                guard Parameter.compare(lhs: lhsActiveid, rhs: rhsActiveid, with: matcher) else { return false } 
                return true 
            case (.m_showWallets__wallets(let lhsWallets), .m_showWallets__wallets(let rhsWallets)):
                guard Parameter.compare(lhs: lhsWallets, rhs: rhsWallets, with: matcher) else { return false } 
                return true 
            case (.m_showWalletEmpty, .m_showWalletEmpty):
                return true 
            case (.m_showInfo__message(let lhsMessage), .m_showInfo__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.m_showError__message(let lhsMessage), .m_showError__message(let rhsMessage)):
                guard Parameter.compare(lhs: lhsMessage, rhs: rhsMessage, with: matcher) else { return false } 
                return true 
            case (.p_presenter_get,.p_presenter_get): return true
			case (.p_presenter_set(let left),.p_presenter_set(let right)): return Parameter<WalletSelectPresentation?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case let .m_showActiveId__activeId(p0): return p0.intValue
            case let .m_showWallets__wallets(p0): return p0.intValue
            case .m_showWalletEmpty: return 0
            case let .m_showInfo__message(p0): return p0.intValue
            case let .m_showError__message(p0): return p0.intValue
            case .p_presenter_get: return 0
			case .p_presenter_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func presenter(getter defaultValue: WalletSelectPresentation?...) -> PropertyStub {
            return Given(method: .p_presenter_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func showActiveId(_ activeId: Parameter<String?>) -> Verify { return Verify(method: .m_showActiveId__activeId(`activeId`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `activeId` label")
		static func showActiveId(activeId: Parameter<String?>) -> Verify { return Verify(method: .m_showActiveId__activeId(`activeId`))}
        static func showWallets(_ wallets: Parameter<[Wallet]>) -> Verify { return Verify(method: .m_showWallets__wallets(`wallets`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallets` label")
		static func showWallets(wallets: Parameter<[Wallet]>) -> Verify { return Verify(method: .m_showWallets__wallets(`wallets`))}
        static func showWalletEmpty() -> Verify { return Verify(method: .m_showWalletEmpty)}
        static func showInfo(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>) -> Verify { return Verify(method: .m_showInfo__message(`message`))}
        static func showError(_ message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>) -> Verify { return Verify(method: .m_showError__message(`message`))}
        static var presenter: Verify { return Verify(method: .p_presenter_get) }
		static func presenter(set newValue: Parameter<WalletSelectPresentation?>) -> Verify { return Verify(method: .p_presenter_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func showActiveId(_ activeId: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_showActiveId__activeId(`activeId`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `activeId` label")
		static func showActiveId(activeId: Parameter<String?>, perform: @escaping (String?) -> Void) -> Perform {
            return Perform(method: .m_showActiveId__activeId(`activeId`), performs: perform)
        }
        static func showWallets(_ wallets: Parameter<[Wallet]>, perform: @escaping ([Wallet]) -> Void) -> Perform {
            return Perform(method: .m_showWallets__wallets(`wallets`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `wallets` label")
		static func showWallets(wallets: Parameter<[Wallet]>, perform: @escaping ([Wallet]) -> Void) -> Perform {
            return Perform(method: .m_showWallets__wallets(`wallets`), performs: perform)
        }
        static func showWalletEmpty(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_showWalletEmpty, performs: perform)
        }
        static func showInfo(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showInfo(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showInfo__message(`message`), performs: perform)
        }
        static func showError(_ message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
        @available(*, deprecated, message: "This constructor is deprecated, and will be removed in v3.1 Possible fix:  remove `message` label")
		static func showError(message: Parameter<String>, perform: @escaping (String) -> Void) -> Perform {
            return Perform(method: .m_showError__message(`message`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }
}

// MARK: - WalletSelectWireframe
class WalletSelectWireframeMock: WalletSelectWireframe, Mock, StaticMock {
    init(sequencing sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst, stubbing stubbingPolicy: StubbingPolicy = .wrap, file: StaticString = #file, line: UInt = #line) {
        self.sequencingPolicy = sequencingPolicy
        self.stubbingPolicy = stubbingPolicy
        self.file = file
        self.line = line
    }

    var matcher: Matcher = Matcher.default
    var stubbingPolicy: StubbingPolicy = .wrap
    var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    private var invocations: [MethodType] = []
    private var methodReturnValues: [Given] = []
    private var methodPerformValues: [Perform] = []
    private var file: StaticString?
    private var line: UInt?

    typealias PropertyStub = Given
    typealias MethodStub = Given
    typealias SubscriptStub = Given

    /// Convenience method - call setupMock() to extend debug information when failure occurs
    public func setupMock(file: StaticString = #file, line: UInt = #line) {
        self.file = file
        self.line = line
    }
    static var matcher: Matcher = Matcher.default
    static var stubbingPolicy: StubbingPolicy = .wrap
    static var sequencingPolicy: SequencingPolicy = .lastWrittenResolvedFirst
    static private var invocations: [StaticMethodType] = []
    static private var methodReturnValues: [StaticGiven] = []
    static private var methodPerformValues: [StaticPerform] = []
    typealias StaticPropertyStub = StaticGiven
    typealias StaticMethodStub = StaticGiven
    static func clear() {
        invocations = []
        methodReturnValues = []
        methodPerformValues = []
    }

    var viewController: UIViewController? {
		get {	invocations.append(.p_viewController_get); return __p_viewController ?? optionalGivenGetterValue(.p_viewController_get, "WalletSelectWireframeMock - stub value for viewController was not defined") }
		set {	invocations.append(.p_viewController_set(.value(newValue))); __p_viewController = newValue }
	}
	private var __p_viewController: (UIViewController)?





    static func assembleModule() -> UIViewController {
        addInvocation(.sm_assembleModule)
		let perform = methodPerformValue(.sm_assembleModule) as? () -> Void
		perform?()
		var __value: UIViewController
		do {
		    __value = try methodReturnValue(.sm_assembleModule).casted()
		} catch {
			Failure("Stub return value not specified for assembleModule(). Use given")
		}
		return __value
    }

    func presentCreate() {
        addInvocation(.m_presentCreate)
		let perform = methodPerformValue(.m_presentCreate) as? () -> Void
		perform?()
    }

    func presentSetting(for wallet: Wallet) {
        addInvocation(.m_presentSetting__for_wallet(Parameter<Wallet>.value(`wallet`)))
		let perform = methodPerformValue(.m_presentSetting__for_wallet(Parameter<Wallet>.value(`wallet`))) as? (Wallet) -> Void
		perform?(`wallet`)
    }

    fileprivate enum StaticMethodType {
        case sm_assembleModule

        static func compareParameters(lhs: StaticMethodType, rhs: StaticMethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.sm_assembleModule, .sm_assembleModule):
                return true 
            }
        }

        func intValue() -> Int {
            switch self {
                case .sm_assembleModule: return 0
            }
        }
    }

    class StaticGiven: StubbedMethod {
        fileprivate var method: StaticMethodType

        private init(method: StaticMethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }


        static func assembleModule(willReturn: UIViewController...) -> StaticMethodStub {
            return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) }))
        }
        static func assembleModule(willProduce: (Stubber<UIViewController>) -> Void) -> StaticMethodStub {
            let willReturn: [UIViewController] = []
			let given: StaticGiven = { return StaticGiven(method: .sm_assembleModule, products: willReturn.map({ Product.return($0) })) }()
			let stubber = given.stub(for: (UIViewController).self)
			willProduce(stubber)
			return given
        }
    }

    struct StaticVerify {
        fileprivate var method: StaticMethodType

        static func assembleModule() -> StaticVerify { return StaticVerify(method: .sm_assembleModule)}
    }

    struct StaticPerform {
        fileprivate var method: StaticMethodType
        var performs: Any

        static func assembleModule(perform: @escaping () -> Void) -> StaticPerform {
            return StaticPerform(method: .sm_assembleModule, performs: perform)
        }
    }

    
    fileprivate enum MethodType {
        case m_presentCreate
        case m_presentSetting__for_wallet(Parameter<Wallet>)
        case p_viewController_get
		case p_viewController_set(Parameter<UIViewController?>)

        static func compareParameters(lhs: MethodType, rhs: MethodType, matcher: Matcher) -> Bool {
            switch (lhs, rhs) {
            case (.m_presentCreate, .m_presentCreate):
                return true 
            case (.m_presentSetting__for_wallet(let lhsWallet), .m_presentSetting__for_wallet(let rhsWallet)):
                guard Parameter.compare(lhs: lhsWallet, rhs: rhsWallet, with: matcher) else { return false } 
                return true 
            case (.p_viewController_get,.p_viewController_get): return true
			case (.p_viewController_set(let left),.p_viewController_set(let right)): return Parameter<UIViewController?>.compare(lhs: left, rhs: right, with: matcher)
            default: return false
            }
        }

        func intValue() -> Int {
            switch self {
            case .m_presentCreate: return 0
            case let .m_presentSetting__for_wallet(p0): return p0.intValue
            case .p_viewController_get: return 0
			case .p_viewController_set(let newValue): return newValue.intValue
            }
        }
    }

    class Given: StubbedMethod {
        fileprivate var method: MethodType

        private init(method: MethodType, products: [Product]) {
            self.method = method
            super.init(products)
        }

        static func viewController(getter defaultValue: UIViewController?...) -> PropertyStub {
            return Given(method: .p_viewController_get, products: defaultValue.map({ Product.return($0) }))
        }

    }

    struct Verify {
        fileprivate var method: MethodType

        static func presentCreate() -> Verify { return Verify(method: .m_presentCreate)}
        static func presentSetting(for wallet: Parameter<Wallet>) -> Verify { return Verify(method: .m_presentSetting__for_wallet(`wallet`))}
        static var viewController: Verify { return Verify(method: .p_viewController_get) }
		static func viewController(set newValue: Parameter<UIViewController?>) -> Verify { return Verify(method: .p_viewController_set(newValue)) }
    }

    struct Perform {
        fileprivate var method: MethodType
        var performs: Any

        static func presentCreate(perform: @escaping () -> Void) -> Perform {
            return Perform(method: .m_presentCreate, performs: perform)
        }
        static func presentSetting(for wallet: Parameter<Wallet>, perform: @escaping (Wallet) -> Void) -> Perform {
            return Perform(method: .m_presentSetting__for_wallet(`wallet`), performs: perform)
        }
    }

    public func given(_ method: Given) {
        methodReturnValues.append(method)
    }

    public func perform(_ method: Perform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    public func verify(_ method: Verify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    private func addInvocation(_ call: MethodType) {
        invocations.append(call)
    }
    private func methodReturnValue(_ method: MethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    private func methodPerformValue(_ method: MethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { MethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    private func matchingCalls(_ method: MethodType) -> [MethodType] {
        return invocations.filter { MethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    private func matchingCalls(_ method: Verify) -> Int {
        return matchingCalls(method.method).count
    }
    private func givenGetterValue<T>(_ method: MethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            onFatalFailure(message)
            Failure(message)
        }
    }
    private func optionalGivenGetterValue<T>(_ method: MethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
    private func onFatalFailure(_ message: String) {
        #if Mocky
        guard let file = self.file, let line = self.line else { return } // Let if fail if cannot handle gratefully
        SwiftyMockyTestObserver.handleMissingStubError(message: message, file: file, line: line)
        #endif
    }

    static public func given(_ method: StaticGiven) {
        methodReturnValues.append(method)
    }

    static public func perform(_ method: StaticPerform) {
        methodPerformValues.append(method)
        methodPerformValues.sort { $0.method.intValue() < $1.method.intValue() }
    }

    static public func verify(_ method: StaticVerify, count: Count = Count.moreOrEqual(to: 1), file: StaticString = #file, line: UInt = #line) {
        let invocations = matchingCalls(method.method)
        MockyAssert(count.matches(invocations.count), "Expected: \(count) invocations of `\(method.method)`, but was: \(invocations.count)", file: file, line: line)
    }

    static private func addInvocation(_ call: StaticMethodType) {
        invocations.append(call)
    }
    static private func methodReturnValue(_ method: StaticMethodType) throws -> Product {
        let candidates = sequencingPolicy.sorted(methodReturnValues, by: { $0.method.intValue() > $1.method.intValue() })
        let matched = candidates.first(where: { $0.isValid && StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) })
        guard let product = matched?.getProduct(policy: self.stubbingPolicy) else { throw MockError.notStubed }
        return product
    }
    static private func methodPerformValue(_ method: StaticMethodType) -> Any? {
        let matched = methodPerformValues.reversed().first { StaticMethodType.compareParameters(lhs: $0.method, rhs: method, matcher: matcher) }
        return matched?.performs
    }
    static private func matchingCalls(_ method: StaticMethodType) -> [StaticMethodType] {
        return invocations.filter { StaticMethodType.compareParameters(lhs: $0, rhs: method, matcher: matcher) }
    }
    static private func matchingCalls(_ method: StaticVerify) -> Int {
        return matchingCalls(method.method).count
    }
    static private func givenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            Failure(message)
        }
    }
    static private func optionalGivenGetterValue<T>(_ method: StaticMethodType, _ message: String) -> T? {
        do {
            return try methodReturnValue(method).casted()
        } catch {
            return nil
        }
    }
}

